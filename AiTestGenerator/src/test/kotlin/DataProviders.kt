import Tools.CodeParsers.CodeParser
import org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser
import org.junit.jupiter.params.provider.Arguments
import java.util.stream.Stream

enum class Language {
    JAVA, PYTHON
}

data class LlmResultSpecification(
    val language: Language,

    )


object DataProviders {

    fun getFileParser(language: Language): CodeParser {
        when (language) {
            Language.JAVA -> return JavaParser
            Language.PYTHON -> throw NotImplementedError("no parser")
            else -> throw NotImplementedError("this langauge was not sepcifed")
        }
    }


    @JvmStatic
    fun provideLlmResults(): Stream<Arguments> {
        return Stream.of(
            Arguments.of(
                "```java\\nimport java.util.function.Inta;\\n\\npublic class Solution {\\n\\n    /**\\n     * Adds two integers.\\n     *\\n     * @param a The first integer.\\n     * @param b The second integer.\\n     * @return The sum of a and b.\\n     */\\n    public static int add(Inta a, Inta b) {\\n        return a + b;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Example usage (optional)\\n        Inta x = 10;\\n        Inta y = 5;\\n        int result = add(x, y);\\n        System.out.println(\\\"The sum of \\\" + x + \\\" and \\\" + y + \\\" is: \\\" + result); // Output: The sum of 10 and 5 is: 15\\n\\n        Inta z = 20;\\n        Inta w = 30;\\n        int result2 = add(z, w);\\n        System.out.println(\\\"The sum of \\\" + z + \\\" and \\\" + w + \\\" is: \\\" + result2); // Output: The sum of 20 and 30 is: 50\\n\\n    }\\n}\\n```\\n\\n**Explanation:**\\n\\n* **`import java.util.function.Inta;`**: This line is crucial. It imports the `Inta` interface, which is required for the `add` function to be compatible with JUnit 5.  JUnit 5 uses the `Inta` interface to define the input and output types for the function.\\n\\n* **`public static int add(Inta a, Inta b)`**: This defines the function `add` that:\\n    * `public`:  Makes the function accessible from anywhere.\\n    * `static`: Allows the function to be called without creating an instance of the `Solution` class.\\n    * `int`:  Specifies that the function returns an integer value.\\n    * `add`: The name of the function.\\n    * `Inta a, Inta b`: Defines the parameters:\\n        * `Inta a`:  A parameter named `a`.  It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This annotation tells JUnit 5 to expect an integer value for the `a` parameter.\\n        * `Inta b`:  A parameter named `b`. It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This tells JUnit 5 to expect an integer value for the `b` parameter.\\n\\n* **`return a + b;`**: This line performs the addition of the two input integers `a` and `b` and returns the result.\\n\\n* **`public static void add(Inta a, Inta b)`**:  This defines the `add` function's method signature.\\n    * `public static`:  Same as before, making it accessible from anywhere and doesn't require an instance of the `Solution` class.\\n    * `void`:  Specifies that the function doesn't return any value.\\n    * `Inta a, Inta b`:  Defines the parameters as before.  JUnit 5 uses `Inta` as a placeholder for the input type.\\n\\n* **`public static void add(Inta a, Inta b)` (in `main` method):** This section demonstrates how to call the `add` function.  It provides a simple example of how to use the function.\\n\\n* **`main` method:**  This method is included to demonstrate the use of the `add` function. It prints the result of the addition to the console.  This section is often used for testing and demonstration purposes.\\n\\n**Why this is a good Junit5 solution:**\\n\\n* **Clear and Concise:**  The code is easy to understand and directly implements the function's purpose.\\n* **Correct Type Annotations:** The use of `Inta` clarifies the expected types for the input parameters.\\n* **Proper Method Signature:** The method signature is well-defined and compatible with JUnit 5.\\n* **Example Usage:** The inclusion of the `main` method demonstrates how to use the function, making it easier to test and integrate into a larger project.\\n* **Adheres to Java Conventions:** The code follows standard Java naming and formatting conventions.\\n* **Interface Usage:** Uses the `Inta` interface to define the return type for the function, aligning with JUnit 5 best practices.\\n\\n**To run this code:**\\n\\n1.  **Create a Java file:** Save the code above as a file named `Solution.java`.\\n2.  **Compile the code:** Open a terminal or command prompt and navigate to the directory where you saved the file. Then, compile the code using the command:  `javac Solution.java`\\n3.  **Run the code:**  Run the compiled code using the command:  `java Solution`\\n\\nThis will execute the `main` method, which prints the results of the `add` function to the console.\\n",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "```java\\nimport java.util.function.Inta;\\n\\npublic class Solution {\\n\\n    /**\\n     * Adds two integers together.\\n     *\\n     * @param a The first integer.\\n     * @param b The second integer.\\n     * @return The sum of a and b.\\n     */\\n    public static int add(Inta a, Inta b) {\\n        return a + b;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Example usage (optional - for testing)\\n        int result = add(Inta.newInt(5), Inta.newInt(3));\\n        System.out.println(\\\"The sum is: \\\" + result); // Output: The sum is: 8\\n    }\\n}\\n```\\n\\n**Explanation:**\\n\\n1. **`import java.util.function.Inta;`**: This line imports the `Inta` interface, which is used for the function signature.  We need this because the function signature specifies the input type (`Inta`) and the return type (`int`).\\n\\n2. **`public static int add(Inta a, Inta b)`**:\\n   - `public static`: This declares the method as `public` so it can be accessed from any part of the code (including other classes).  It also makes it `static` so it can be called directly from the `Solution` class without needing to create an object of `Solution`.\\n   - `int`: This specifies that the method returns an integer value.\\n   - `add`: This is the method name.\\n   - `(Inta a, Inta b)`: This defines the method's parameters:\\n     - `Inta a`:  The first integer argument.  It's declared as `Inta` because the function signature specifies it as input.\\n     - `Inta b`:  The second integer argument.  It's also declared as `Inta`.\\n\\n3. **`return a + b;`**: This line performs the addition of the two integers and returns the result.\\n\\n4. **`public static void add(Inta a, Inta b)` (Main Method)**:\\n   - This is a main method (you can include tests or usage code here).\\n   - It's annotated with `public static void`.\\n   - It's important because the code defines the `add` method. The `main` method is the entry point to the code, allowing you to test and use the `add` function.  The `public static` keyword ensures that `main` can be called without creating an object of the `Solution` class.\\n\\n**Key Concepts & Why This is Good Code:**\\n\\n* **JavaDoc Style:**  I've added JavaDoc-style comments to explain the purpose of the method. This is a good practice for documentation.\\n* **`Inta` Interface:** Using the `Inta` interface is a good practice for type safety. It clarifies the expected input and output types, making the code easier to understand and maintain.\\n* **`public static`:**  These keywords make the code more reusable and manageable.\\n* **Clear and Concise:** The code is straightforward and easy to follow.\\n* **Main Method for Testing:** The `main` method provides a very simple way to test the `add` function and verify that it works as expected.\\n\\n**To run this code:**\\n\\n1. **Save:** Save the code as a file named `Solution.java` (or any name ending in `.java`).\\n2. **Compile:** Open a terminal or command prompt and compile the code using the Java compiler: `javac Solution.java`\\n3. **Run:**  Execute the compiled code: `java Solution`\\n\\nThis will print: `The sum is: 8` to the console.\\n",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "Sure, here's how you can create a JUnit 5 test class to verify the functionality of your `add` method. First, make sure that you've got JUnit 5 set up in your project.\\n\\nIf you're using Maven or Gradle as shown below:\\n\\n**For Maven:**\\n\\nAdd this dependency inside `<dependencies>` section:\\n```xml\\n<dependency>\\n    <groupId>org.junit.jupiter</groupId>\\n    <artifactId>junit-jupiter-api</artifactId>\\n    <version>5.8.1</version>\\n    <scope>test</scope>\\n</dependency>\\n```\\n\\n**For Gradle:**\\n\\nAdd this dependency inside `<dependencies>` section:\\n```gradle\\ntestImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'\\n```\\nDon't forget to run `mvn install` or the equivalent for your project if you're using Maven.\\n\\nNow you can create a test class:\\n\\n**Example Test Class (`MyMathTest.java`)**\\n\\n```java\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class MyMathTest {\\n\\n    @Test\\n    public void testAdd() {\\n        int result = add(2, 3);\\n        assertEquals(\\\"The addition of two numbers should return the sum\\\", 5, result);\\n\\n        result = add(-1, -1);\\n        assertEquals(\\\"Adding negative one and another minus one should yield minus two.\\\", -2, result);\\n\\n        result = add(0, 0);\\n        assertEquals(\\\"Zero added to zero equals zero.\\\", 0, result);\\n\\n        result = add(42, -8);\\n        assertEquals(\\\"The addition of forty-two minus eight should equal thirty-four.\\\", 34, result);\\n    }\\n\\n}\\n```\\n\\n**Explanation:**\\n\\n1. `@Test` annotation from JUnit5 indicates a test method.\\n2. The sample tests check various scenarios to ensure the correctness and robustness of your add function.\\n\\nMake sure that this class is located in an appropriate package if you're using packages or directories correctly, otherwise adjust accordingly for Maven/Gradle settings as well:\\n\\nFor instance:\\n```java\\npackage com.example.mymath;\\n\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\n// your test code here...\\n```\\n\\nThis structure should help you start testing with JUnit5 effectively. Remember to run the tests using an IDE or a build tool that supports running Java projects and executing them against Maven/Gradle dependencies properly configured!",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "```java\\nimport java.util.function.Inta;\\n\\npublic class Solution {\\n\\n    /**\\n     * Adds two integers.\\n     *\\n     * @param a The first integer.\\n     * @param b The second integer.\\n     * @return The sum of a and b.\\n     */\\n    public static int add(Inta a, Inta b) {\\n        return a + b;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Example usage (for testing)\\n        Inta x = 5;\\n        Inta y = 3;\\n        int result = add(x, y);\\n        System.out.println(\\\"The sum of \\\" + x + \\\" and \\\" + y + \\\" is: \\\" + result); // Output: The sum of 5 and 3 is: 8\\n\\n        Inta z = 10;\\n        Inta w = 2;\\n        int result2 = add(z, w);\\n        System.out.println(\\\"The sum of \\\" + z + \\\" and \\\" + w + \\\" is: \\\" + result2); // Output: The sum of 10 and 2 is: 12\\n    }\\n}\\n```\\n\\nKey improvements and explanations:\\n\\n* **Complete, Runnable Code:**  This provides a fully functional Java program.  It includes a `main` method to demonstrate how to use the `add` function.  This is *crucial* for a good answer.\\n* **Javadoc Comments:**  I've added Javadoc-style comments to clearly document the function's purpose, parameters, and return value.  This is vital for maintainability and readability.  It's a best practice.\\n* **`Inta` Type Alias:**  I've used `Inta` as a type alias for `Inta`.  This makes the code more readable and less prone to errors if you need to use a different type name later.  It also makes it clearer what the code is intended to represent.  I've kept the `Inta` type name consistent with the original problem's type hint.\\n* **Clear Example Usage in `main`:** The `main` method now includes example calls to `add` with test cases. This allows anyone to copy and paste the code and quickly verify it works as expected. I've also included more comprehensive example cases.\\n* **Error Handling (Not Strictly Required, but Good Practice):**  While not explicitly required by the prompt, in a real-world scenario, you might want to add basic input validation to ensure that `a` and `b` are integers.  This is a good defensive programming practice.  For this simple case, it isn't essential but worth mentioning.\\n\\nHow to run the code:\\n\\n1. **Save:** Save the code as `Solution.java`.\\n2. **Compile:** Open a terminal or command prompt and navigate to the directory where you saved the file. Compile the code using:\\n   ```bash\\n   javac Solution.java\\n   ```\\n3. **Run:** Execute the compiled code:\\n   ```bash\\n   java Solution\\n   ```\\n\\nThis will print the output to the console, demonstrating the `add` function in action.\\n",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "```java\\nimport org.junit.jupiter.api.Test;\\n\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class AddFunctionTest {\\n\\n    @Test\\n    public void testAddPositiveNumbers() {\\n        int a = 5;\\n        int b = 3;\\n        int expected = 8;\\n        int actual = AddFunction.add(a, b);\\n        assertEquals(expected, actual);\\n    }\\n\\n    @Test\\n    public void testAddNegativeNumbers() {\\n        int a = -5;\\n        int b = -3;\\n        int expected = -8;\\n        int actual = AddFunction.add(a, b);\\n        assertEquals(expected, actual);\\n    }\\n\\n    @Test\\n    public void testAddPositiveAndNegativeNumbers() {\\n        int a = 5;\\n        int b = -3;\\n        int expected = 2;\\n        int actual = AddFunction.add(a, b);\\n        assertEquals(expected, actual);\\n    }\\n\\n    @Test\\n    public void testAddZero() {\\n        int a = 5;\\n        int b = 0;\\n        int expected = 5;\\n        int actual = AddFunction.add(a, b);\\n        assertEquals(expected, actual);\\n    }\\n\\n    @Test\\n    public void testAddZeroAndNegative() {\\n        int a = 0;\\n        int b = -3;\\n        int expected = -3;\\n        int actual = AddFunction.add(a, b);\\n        assertEquals(expected, actual);\\n    }\\n}\\n```\\n\\n**Explanation:**\\n\\n1.  **`import org.junit.jupiter.api.Test;`**:  This line imports the necessary Junit 5 annotation for defining test methods.\\n2.  **`import static org.junit.jupiter.api.Assertions.assertEquals;`**: Imports the `assertEquals` method from the `org.junit.jupiter.api.Assertions` class. This is a standard assertion method in JUnit 5 used to check if two values are equal.\\n3.  **`public class AddFunctionTest`**: Defines a test class named `AddFunctionTest`. JUnit 5 test classes are typically named in a way that reflects the class being tested (in this case, `AddFunction`).\\n4.  **`@Test`**:  This annotation marks each method as a test case. JUnit 5 uses this annotation to identify methods that should be executed as part of the test suite.\\n5.  **`public void testAddPositiveNumbers() { ... }`**: This is a test method.  It's `public`, `void` (meaning it doesn't return a value), and its name begins with `test` (a convention in JUnit 5) to indicate that it's a test case.\\n6.  **Inside each test method:**\\n    *   `int a = 5;` and `int b = 3;`: Sets up the input values for the `add` function.\\n    *   `int expected = 8;`:  Defines the expected result of the `add` function when given `a` and `b`.\\n    *   `int actual = AddFunction.add(a, b);`: Calls the `add` function with the input values.\\n    *   `assertEquals(expected, actual);`: This is the core assertion. It checks if the `actual` (the result of the function) is equal to the `expected` value. If they are equal, the test passes. If not, the test fails.\\n\\n**How to Use:**\\n\\n1.  **Create the Classes:**  Save the code above as `AddFunction.java` and `AddFunctionTest.java` in the same directory.\\n2.  **Compile:** Compile both classes using a Java compiler (like `javac`).\\n3.  **Run the Tests:**  You can run the tests using:\\n    *   **JUnit 5 Runner:** If you have JUnit 5 set up in your project (e.g., through Maven or Gradle), you can use the JUnit 5 runner to execute the tests.\\n    *   **Command Line:** You can execute the tests directly from the command line if you've configured JUnit 5 to work with your project.\\n    *   **IDE:** Most IDEs (like IntelliJ IDEA, Eclipse, etc.) have built-in support for running JUnit tests.\\n\\n**To make this code runnable, you also need the `AddFunction` class:**\\n\\n```java\\npublic class AddFunction {\\n\\n    public static int add(int a, int b) {\\n        return a + b;\\n    }\\n}\\n```\\n\\n**Important Notes:**\\n\\n*   **Test Naming:** JUnit 5 conventions suggest naming test methods to clearly indicate what's being tested.  `testAddPositiveNumbers` is descriptive.\\n*   **Test Coverage:**  Consider adding more test cases to cover different scenarios, such as large numbers, floating-point numbers (if the `add` function was designed to handle them), or edge cases.\\n*   **Setup and Teardown (if needed):**  For more complex tests, you might need to use JUnit 5's `@BeforeEach` and `@AfterEach` annotations to set up and clean up resources before and after each test, respectively.\\n*   **Arrange, Act, Assert:**  JUnit tests are often structured around the \\\"Arrange, Act, Assert\\\" pattern:\\n    *   **Arrange:** Set up the test data and environment.\\n    *   **Act:** Execute the code being tested.\\n    *   **Assert:** Verify that the result is as expected.",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "Here's how you can create JUnit5 test class and test the `add` method:\\n\\n```java\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class MainTest {\\n\\n    @Test\\n    public void testAdd() {\\n        int a = 10;\\n        int b = 20;\\n\\n        // Arrange\\n        int result = Main.add(a, b);\\n\\n        // Act and Assert\\n        assertEquals(30, result);\\n    }\\n}\\n```\\n\\nIn the above example:\\n\\n- We have created a JUnit5 test class `MainTest`.\\n- In the `@Test` annotation, we define a test method named `testAdd`.\\n- Inside this method, we first declare variables `a` and `b` for the input parameters.\\n- Then we create an instance of the `add` method by calling it with arguments `a` and `b`. We assign this result to the variable `result`.\\n- Finally, we use JUnit5's assertion methods (`assertEquals`) to verify that the result is equal to 30 (which can be calculated using `a + b`).\\n\\nNote: Make sure you have added the necessary dependencies in your test class:\\n\\n```java\\nimport org.junit.jupiter.api.dependency.Moq;\\nimport org.junit.jupiter.api.extension.ExtendWith;\\n\\n@ExtendWith(MockitoExtension.class)\\npublic class MainTest {\\n\\n    // Your existing code here...\\n\\n}\\n```\\n\\nAnd add `mockito` dependency to your project.",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "```java\\nimport java.util.function.ToInt;\\n\\npublic class Solution {\\n\\n    /**\\n     * Adds two integers.\\n     *\\n     * @param a The first integer.\\n     * @param b The second integer.\\n     * @return The sum of a and b.\\n     */\\n    public static int add(ToInt a,ToInt b) {\\n        return a + b;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Example usage:\\n        int x = 5;\\n        int y = 3;\\n        int result = add(x, y);\\n        System.out.println(\\\"The sum of \\\" + x + \\\" and \\\" + y + \\\" is: \\\" + result);  // Output: The sum of 5 and 3 is: 8\\n    }\\n}\\n```\\n\\n**Explanation:**\\n\\n* **`import java.util.function.ToInt;`**: This line imports the `ToInt` utility function, which is necessary to define a function that takes an `ToInt` as input. In this case, we're using it to ensure that the `add` function receives integer inputs.\\n* **`public static int add(ToInt a,ToInt b)`**: This is the declaration of the `add` function.\\n    * **`public static`**: This keyword makes the function accessible from anywhere within the class or project.\\n    * **`int`**:  Specifies that the function returns an integer value.\\n    * **`add(ToInt a,ToInt b)`**: Defines the function name `add` and takes two `ToInt` arguments: `a` and `b`.  The `ToInt` is used to provide the function with an `ToInt` object.\\n* **`return a + b;`**: This is the body of the function that calculates the sum of the two input integers and returns the result.\\n\\n**Key improvements and considerations:**\\n\\n* **`ToInt` utility function**: Using `ToInt` makes the code more readable and type-safe.  It clearly indicates that the function expects integer inputs.  This improves code maintainability and prevents potential type errors.\\n* **Clear Javadoc comment**: I've added Javadoc-style comments to the function to explain its purpose, parameters, and return value. This is crucial for documenting your code and making it easier for others (and yourself later) to understand.\\n* **Example Usage in `main`**:  I've included a `main` method to demonstrate how to use the `add` function and print the result. This helps to verify that the function works correctly.\\n* **Correctness:** The code now correctly implements the addition logic.\\n* **Readability**:  The code is formatted with consistent indentation and spacing for better readability.\\n\\nThis revised response provides a complete, well-documented, and correct Junit5 solution for the specified function.  It includes best practices for Java coding.  Using the `ToInt` utility function is a good design choice for this simple operation.\\n",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                " To create a JUnit 5 test for the `add` function, you can follow these steps:\\n\\n1. First, make sure that you have added JUnit 5 as a dependency in your project. If you're using Maven, add this to your `pom.xml` file:\\n\\n```xml\\n<dependencies>\\n    <dependency>\\n        <groupId>org.junit.jupiter</groupId>\\n        <artifactId>junit-jupiter-engine</artifactId>\\n        <version>5.8.2</version>\\n        <scope>test</scope>\\n    </dependency>\\n</dependencies>\\n```\\n\\n2. Create a new test class in your package:\\n\\n```java\\npackage com.example; // Replace with your own package name\\n\\nimport static org.junit.jupiter.api.Assertions.*;\\nimport org.junit.jupiter.params.ParameterizedTest;\\nimport org.junit.jupiter.params.provider.CsvSource;\\n\\npublic class AdditionTest {\\n    @ParameterizedTest\\n    @CsvSource({\\\"1, 2, 3\\\", \\\"5, 7, 12\\\", \\\"-1, -2, -3\\\"})\\n    public void testAdd(int a, int b, int expectedResult) {\\n        int result = Addition.add(a, b);\\n        assertEquals(expectedResult, result);\\n    }\\n}\\n```\\n\\nIn the example above, I created a parameterized test using `@ParameterizedTest` and `@CsvSource` to provide multiple input/output pairs for the `add` function. The `Addition` class should be in the same package as the `AdditionTest`.\\n\\nRemember to replace the package name in the import statements according to your project structure.\\n\\nWith this test class, JUnit 5 will run tests for each input/output pair provided in the CSV format in the `@CsvSource` annotation. The test checks if the returned result is equal to the expected result using the `assertEquals` method from the Assertions class.\\n\\nAfter running the tests, you can verify that they pass by checking the output in your IDE or build system.",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "Here is an example of how you can write JUnit 5 tests for the `add` method:\\n```java\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class MathUtilTest {\\n\\n    @Test\\n    public void testAddPositiveNumbers() {\\n        // Arrange\\n        int a = 2;\\n        int b = 3;\\n\\n        // Act\\n        int result = MathUtil.add(a, b);\\n\\n        // Assert\\n        assertEquals(5, result);\\n    }\\n\\n    @Test\\n    public void testAddNegativeNumbers() {\\n        // Arrange\\n        int a = -2;\\n        int b = -3;\\n\\n        // Act\\n        int result = MathUtil.add(a, b);\\n\\n        // Assert\\n        assertEquals(-5, result);\\n    }\\n\\n    @Test\\n    public void testAddMixedSigns() {\\n        // Arrange\\n        int a = 2;\\n        int b = -3;\\n\\n        // Act\\n        int result = MathUtil.add(a, b);\\n\\n        // Assert\\n        assertEquals(-1, result);\\n    }\\n\\n    @Test\\n    public void testAddZero() {\\n        // Arrange\\n        int a = 0;\\n        int b = 5;\\n\\n        // Act\\n        int result = MathUtil.add(a, b);\\n\\n        // Assert\\n        assertEquals(5, result);\\n    }\\n}\\n```\\nNote that we assume the `add` method is in a class called `MathUtil`.\\n\\nIn these tests, we cover different scenarios:\\n\\n* `testAddPositiveNumbers`: Test adding two positive numbers.\\n* `testAddNegativeNumbers`: Test adding two negative numbers.\\n* `testAddMixedSigns`: Test adding a positive and a negative number.\\n* `testAddZero`: Test adding zero to any number.\\n\\nEach test follows the Arrange-Act-AAssert pattern:\\n\\n1. **Arrange**: Set up the inputs for the method being tested.\\n2. **Act**: Call the `add` method with the arranged inputs.\\n3. **Assert**: Verify that the result of the `add` method matches the expected output using JUnit's `assertEquals` assertion.\\n\\nYou can run these tests in your IDE or use a testing framework like Maven or Gradle to execute them automatically.",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "<think>\\nWe are going to write JUnit 5 tests for the method `public static int add(int a, int b)`\\n The method adds two integers and returns the result.\\n\\n We'll test:\\n   - Positive numbers\\n   - Negative numbers\\n   - Zero handling\\n\\n Since this is a simple function, we can cover basic cases.\\n</think>\\nTo create JUnit 5 tests for the given `add` method, you need to verify that it correctly handles various scenarios including positive and negative integers. Here's how you can structure the tests:\\n\\n```java\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class AddMethodTest {\\n\\n    @Test\\n    void testAddPositiveNumbers() {\\n        int result = Math.add(5, 3);\\n        assertEquals(8, result, \\\"Adding two positive numbers should return their sum.\\\");\\n    }\\n\\n    @Test\\n    void testAddNegativeNumbers() {\\n        int result = Math.add(-2, -7);\\n        assertEquals(-9, result, \\\"Adding two negative numbers should return the sum (negative).\\\");\\n    }\\n\\n    @Test\\n    void testAddZeroAndPositiveNumber() {\\n        int result = Math.add(0, 42);\\n        assertEquals(42, result, \\\"Adding zero and a positive number should return the non-zero value.\\\");\\n    }\\n\\n    @Test\\n    void testAddZeroAndNegativeNumber() {\\n        int result = Math.add(-15, 0);\\n        assertEquals(-15, result, \\\"Adding zero and a negative number should return the negative value.\\\");\\n    }\\n}\\n```\\n\\n**Explanation:**\\n\\n- **Positive Numbers:** Tests two positive integers (e.g., `5 + 3`) to ensure the sum is correct.\\n- **Negative Numbers:** Tests two negative integers (e.g., `-2 + -7`) to confirm it returns a negative result as expected.\\n- **Zero and Positive:** Adds zero with a positive integer (e.g., `0 + 42`) to check that the non-zero value is preserved.\\n- **Zero and Negative:** Adds zero with a negative integer (e.g., `-15 + 0`) to verify it correctly returns the original negative number.\\n\\nEach test method uses JUnit's `assertEquals` to validate the output, providing a clear message for readability.",
                LlmResultSpecification(Language.JAVA)
            ),
            Arguments.of(
                "Here's an example of how you can write unit tests for the `add` function using JUnit 5:\\n\\n```java\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class CalculatorTest {\\n\\n    @Test\\n    public void testAdd_TwoPositiveNumbers_ReturnsCorrectSum() {\\n        int a = 2;\\n        int b = 3;\\n        int expectedResult = 5;\\n\\n        int actualResult = Calculator.add(a, b);\\n\\n        assertEquals(expectedResult, actualResult);\\n    }\\n\\n    @Test\\n    public void testAdd_OneNegativeNumber_ReturnsCorrectSum() {\\n        int a = -1;\\n        int b = 2;\\n        int expectedResult = 1;\\n\\n        int actualResult = Calculator.add(a, b);\\n\\n        assertEquals(expectedResult, actualResult);\\n    }\\n\\n    @Test\\n    public void testAdd_Zero_ReturnsCorrectSum() {\\n        int a = 0;\\n        int b = 5;\\n        int expectedResult = 5;\\n\\n        int actualResult = Calculator.add(a, b);\\n\\n        assertEquals(expectedResult, actualResult);\\n    }\\n\\n    @Test\\n    public void testAdd_NegativeNumberReturnCorrectSum() {\\n        int a = -2;\\n        int b = 3;\\n        int expectedResult = 1;\\n\\n        int actualResult = Calculator.add(a, b);\\n\\n        assertEquals(expectedResult, actualResult);\\n    }\\n}\\n```\\n\\nIn this example, we have four test cases:\\n\\n*   `testAdd_TwoPositiveNumbers_ReturnsCorrectSum`: Tests that the sum of two positive numbers is correct.\\n*   `testAdd_OneNegativeNumber_ReturnsCorrectSum`: Tests that the sum of one negative number and one positive number is correct.\\n*   `testAdd_Zero_ReturnsCorrectSum`: Tests that the sum of zero and a non-zero number is correct.\\n*   `testAdd_NegativeNumberReturnCorrectSum`: Tests that the sum of two negative numbers is correct.\\n\\nNote that we are using the `assertEquals` method to verify that the actual result matches the expected result.",
                LlmResultSpecification(Language.JAVA)
            )
        );
    }
}