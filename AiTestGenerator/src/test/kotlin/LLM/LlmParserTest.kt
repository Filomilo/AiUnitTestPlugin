package LLM

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.Arguments
import org.junit.jupiter.params.provider.MethodSource
import java.util.stream.Stream

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class LlmParserTest {


    fun responseAndListingProvider(): Stream<Arguments> {
        "```java\\nimport java.util.function.Inta;\\n\\npublic class Solution {\\n\\n    /**\\n     * Adds two integers.\\n     *\\n     * @param a The first integer.\\n     * @param b The second integer.\\n     * @return The sum of a and b.\\n     */\\n    public static int add(Inta a, Inta b) {\\n        return a + b;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Example usage (optional)\\n        Inta x = 10;\\n        Inta y = 5;\\n        int result = add(x, y);\\n        System.out.println(\\\"The sum of \\\" + x + \\\" and \\\" + y + \\\" is: \\\" + result); // Output: The sum of 10 and 5 is: 15\\n\\n        Inta z = 20;\\n        Inta w = 30;\\n        int result2 = add(z, w);\\n        System.out.println(\\\"The sum of \\\" + z + \\\" and \\\" + w + \\\" is: \\\" + result2); // Output: The sum of 20 and 30 is: 50\\n\\n    }\\n}\\n```\\n\\n**Explanation:**\\n\\n* **`import java.util.function.Inta;`**: This line is crucial. It imports the `Inta` interface, which is required for the `add` function to be compatible with JUnit 5.  JUnit 5 uses the `Inta` interface to define the input and output types for the function.\\n\\n* **`public static int add(Inta a, Inta b)`**: This defines the function `add` that:\\n    * `public`:  Makes the function accessible from anywhere.\\n    * `static`: Allows the function to be called without creating an instance of the `Solution` class.\\n    * `int`:  Specifies that the function returns an integer value.\\n    * `add`: The name of the function.\\n    * `Inta a, Inta b`: Defines the parameters:\\n        * `Inta a`:  A parameter named `a`.  It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This annotation tells JUnit 5 to expect an integer value for the `a` parameter.\\n        * `Inta b`:  A parameter named `b`. It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This tells JUnit 5 to expect an integer value for the `b` parameter.\\n\\n* **`return a + b;`**: This line performs the addition of the two input integers `a` and `b` and returns the result.\\n\\n* **`public static void add(Inta a, Inta b)`**:  This defines the `add` function's method signature.\\n    * `public static`:  Same as before, making it accessible from anywhere and doesn't require an instance of the `Solution` class.\\n    * `void`:  Specifies that the function doesn't return any value.\\n    * `Inta a, Inta b`:  Defines the parameters as before.  JUnit 5 uses `Inta` as a placeholder for the input type.\\n\\n* **`public static void add(Inta a, Inta b)` (in `main` method):** This section demonstrates how to call the `add` function.  It provides a simple example of how to use the function.\\n\\n* **`main` method:**  This method is included to demonstrate the use of the `add` function. It prints the result of the addition to the console.  This section is often used for testing and demonstration purposes.\\n\\n**Why this is a good Junit5 solution:**\\n\\n* **Clear and Concise:**  The code is easy to understand and directly implements the function's purpose.\\n* **Correct Type Annotations:** The use of `Inta` clarifies the expected types for the input parameters.\\n* **Proper Method Signature:** The method signature is well-defined and compatible with JUnit 5.\\n* **Example Usage:** The inclusion of the `main` method demonstrates how to use the function, making it easier to test and integrate into a larger project.\\n* **Adheres to Java Conventions:** The code follows standard Java naming and formatting conventions.\\n* **Interface Usage:** Uses the `Inta` interface to define the return type for the function, aligning with JUnit 5 best practices.\\n\\n**To run this code:**\\n\\n1.  **Create a Java file:** Save the code above as a file named `Solution.java`.\\n2.  **Compile the code:** Open a terminal or command prompt and navigate to the directory where you saved the file. Then, compile the code using the command:  `javac Solution.java`\\n3.  **Run the code:**  Run the compiled code using the command:  `java Solution`\\n\\nThis will execute the `main` method, which prints the results of the `add` function to the console.\\n"
        return Stream.of<Arguments>(
            Arguments.of(
                """
            ```java\nimport java.util.function.Inta;\n\npublic class Solution {\n\n    /**\n     * Adds two integers.\n     *\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return The sum of a and b.\n     */\n    public static int add(Inta a, Inta b) {\n        return a + b;\n    }\n\n    public static void main(String[] args) {\n        // Example usage (optional)\n        Inta x = 10;\n        Inta y = 5;\n        int result = add(x, y);\n        System.out.println(\"The sum of \" + x + \" and \" + y + \" is: \" + result); // Output: The sum of 10 and 5 is: 15\n\n        Inta z = 20;\n        Inta w = 30;\n        int result2 = add(z, w);\n        System.out.println(\"The sum of \" + z + \" and \" + w + \" is: \" + result2); // Output: The sum of 20 and 30 is: 50\n\n    }\n}\n```\n\n**Explanation:**\n\n* **`import java.util.function.Inta;`**: This line is crucial. It imports the `Inta` interface, which is required for the `add` function to be compatible with JUnit 5.  JUnit 5 uses the `Inta` interface to define the input and output types for the function.\n\n* **`public static int add(Inta a, Inta b)`**: This defines the function `add` that:\n    * `public`:  Makes the function accessible from anywhere.\n    * `static`: Allows the function to be called without creating an instance of the `Solution` class.\n    * `int`:  Specifies that the function returns an integer value.\n    * `add`: The name of the function.\n    * `Inta a, Inta b`: Defines the parameters:\n        * `Inta a`:  A parameter named `a`.  It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This annotation tells JUnit 5 to expect an integer value for the `a` parameter.\n        * `Inta b`:  A parameter named `b`. It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This tells JUnit 5 to expect an integer value for the `b` parameter.\n\n* **`return a + b;`**: This line performs the addition of the two input integers `a` and `b` and returns the result.\n\n* **`public static void add(Inta a, Inta b)`**:  This defines the `add` function's method signature.\n    * `public static`:  Same as before, making it accessible from anywhere and doesn't require an instance of the `Solution` class.\n    * `void`:  Specifies that the function doesn't return any value.\n    * `Inta a, Inta b`:  Defines the parameters as before.  JUnit 5 uses `Inta` as a placeholder for the input type.\n\n* **`public static void add(Inta a, Inta b)` (in `main` method):** This section demonstrates how to call the `add` function.  It provides a simple example of how to use the function.\n\n* **`main` method:**  This method is included to demonstrate the use of the `add` function. It prints the result of the addition to the console.  This section is often used for testing and demonstration purposes.\n\n**Why this is a good Junit5 solution:**\n\n* **Clear and Concise:**  The code is easy to understand and directly implements the function's purpose.\n* **Correct Type Annotations:** The use of `Inta` clarifies the expected types for the input parameters.\n* **Proper Method Signature:** The method signature is well-defined and compatible with JUnit 5.\n* **Example Usage:** The inclusion of the `main` method demonstrates how to use the function, making it easier to test and integrate into a larger project.\n* **Adheres to Java Conventions:** The code follows standard Java naming and formatting conventions.\n* **Interface Usage:** Uses the `Inta` interface to define the return type for the function, aligning with JUnit 5 best practices.\n\n**To run this code:**\n\n1.  **Create a Java file:** Save the code above as a file named `Solution.java`.\n2.  **Compile the code:** Open a terminal or command prompt and navigate to the directory where you saved the file. Then, compile the code using the command:  `javac Solution.java`\n3.  **Run the code:**  Run the compiled code using the command:  `java Solution`\n\nThis will execute the `main` method, which prints the results of the `add` function to the console.\n
        """.trimIndent(), "java", listOf<String>(
                    """
                import java.util.function.Inta;\n\npublic class Solution {\n\n    /**\n     * Adds two integers.\n     *\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return The sum of a and b.\n     */\n    public static int add(Inta a, Inta b) {\n        return a + b;\n    }\n\n    public static void main(String[] args) {\n        // Example usage (optional)\n        Inta x = 10;\n        Inta y = 5;\n        int result = add(x, y);\n        System.out.println(\"The sum of \" + x + \" and \" + y + \" is: \" + result); // Output: The sum of 10 and 5 is: 15\n\n        Inta z = 20;\n        Inta w = 30;\n        int result2 = add(z, w);\n        System.out.println(\"The sum of \" + z + \" and \" + w + \" is: \" + result2); // Output: The sum of 20 and 30 is: 50\n\n    }\n}\n
            """.trimIndent()
                )
            ),
//
            Arguments.of(
                """
                    ```java\nimport java.util.function.Inta;\n\npublic class Solution {\n\n    /**\n     * Adds two integers.\n     *\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return The sum of a and b.\n     */\n    public static int add(Inta a, Inta b) {\n        return a + b;\n    }\n\n    public static void main(String[] args) {\n        // Example usage (optional)\n        Inta x = 10;\n        Inta y = 5;\n        int result = add(x, y);\n        System.out.println(\"The sum of \" + x + \" and \" + y + \" is: \" + result); // Output: The sum of 10 and 5 is: 15\n\n        Inta z = 20;\n        Inta w = 30;\n        int result2 = add(z, w);\n        System.out.println(\"The sum of \" + z + \" and \" + w + \" is: \" + result2); // Output: The sum of 20 and 30 is: 50\n\n    }\n}\n```\n\n**Explanation:**\n\n* **`import java.util.function.Inta;`**: This line is crucial. It imports the `Inta` interface, which is required for the `add` function to be compatible with JUnit 5.  JUnit 5 uses the `Inta` interface to define the input and output types for the function.\n\n* **`public static int add(Inta a, Inta b)`**: This defines the function `add` that:\n    * `public`:  Makes the function accessible from anywhere.\n    * `static`: Allows the function to be called without creating an instance of the `Solution` class.\n    * `int`:  Specifies that the function returns an integer value.\n    * `add`: The name of the function.\n    * `Inta a, Inta b`: Defines the parameters:\n        * `Inta a`:  A parameter named `a`.  It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This annotation tells JUnit 5 to expect an integer value for the `a` parameter.\n        * `Inta b`:  A parameter named `b`. It's annotated as `Inta` because JUnit 5 uses this type for input parameters.  This tells JUnit 5 to expect an integer value for the `b` parameter.\n\n* **`return a + b;`**: This line performs the addition of the two input integers `a` and `b` and returns the result.\n\n* **`public static void add(Inta a, Inta b)`**:  This defines the `add` function's method signature.\n    * `public static`:  Same as before, making it accessible from anywhere and doesn't require an instance of the `Solution` class.\n    * `void`:  Specifies that the function doesn't return any value.\n    * `Inta a, Inta b`:  Defines the parameters as before.  JUnit 5 uses `Inta` as a placeholder for the input type.\n\n* **`public static void add(Inta a, Inta b)` (in `main` method):** This section demonstrates how to call the `add` function.  It provides a simple example of how to use the function.\n\n* **`main` method:**  This method is included to demonstrate the use of the `add` function. It prints the result of the addition to the console.  This section is often used for testing and demonstration purposes.\n\n**Why this is a good Junit5 solution:**\n\n* **Clear and Concise:**  The code is easy to understand and directly implements the function's purpose.\n* **Correct Type Annotations:** The use of `Inta` clarifies the expected types for the input parameters.\n* **Proper Method Signature:** The method signature is well-defined and compatible with JUnit 5.\n* **Example Usage:** The inclusion of the `main` method demonstrates how to use the function, making it easier to test and integrate into a larger project.\n* **Adheres to Java Conventions:** The code follows standard Java naming and formatting conventions.\n* **Interface Usage:** Uses the `Inta` interface to define the return type for the function, aligning with JUnit 5 best practices.\n\n**To run this code:**\n\n1.  **Create a Java file:** Save the code above as a file named `Solution.java`.\n2.  **Compile the code:** Open a terminal or command prompt and navigate to the directory where you saved the file. Then, compile the code using the command:  `javac Solution.java`\n3.  **Run the code:**  Run the compiled code using the command:  `java Solution`\n\nThis will execute the `main` method, which prints the results of the `add` function to the console.\n
                """.trimIndent(),
                "java",
                listOf<String>(
                    """
                        import java.util.function.Inta;\n\npublic class Solution {\n\n    /**\n     * Adds two integers.\n     *\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return The sum of a and b.\n     */\n    public static int add(Inta a, Inta b) {\n        return a + b;\n    }\n\n    public static void main(String[] args) {\n        // Example usage (optional)\n        Inta x = 10;\n        Inta y = 5;\n        int result = add(x, y);\n        System.out.println(\"The sum of \" + x + \" and \" + y + \" is: \" + result); // Output: The sum of 10 and 5 is: 15\n\n        Inta z = 20;\n        Inta w = 30;\n        int result2 = add(z, w);\n        System.out.println(\"The sum of \" + z + \" and \" + w + \" is: \" + result2); // Output: The sum of 20 and 30 is: 50\n\n    }\n}\n
                    """.trimIndent()
                )
            ),
            Arguments.of(
                """
                    ```python\nimport pytest\n\ndef add(a, b):\n    return a + b\n\npytest.test(lambda: add(2, 3))\n```\n\n**Explanation:**\n\n1. **`import pytest`**: This line imports the Pytest framework, which is used for writing and running tests.\n2. **`def add(a, b):`**: This defines the function `add` that takes two arguments, `a` and `b`, and returns their sum.\n3. **`return a + b`**: This line simply returns the sum of `a` and `b`.\n4. **`pytest.test(lambda: add(2, 3))`**: This is the core of the test.\n   - `pytest.test()`: This function runs the provided code as a test case.\n   - `lambda: add(2, 3)`: This creates an anonymous function (lambda expression). This lambda expression calls the `add` function with the arguments `2` and `3`.  The `lambda` allows us to define a small, self-contained test case.\n   - The `pytest` framework will then execute this test case and verify that it produces the correct output.\n\n**To run this test:**\n\n1.  **Save the code:** Save the above code as a Python file (e.g., `test_add.py`).\n2.  **Run Pytest:** Open a terminal or command prompt, navigate to the directory where you saved the file, and run the command:\n\n    ```bash\n    pytest\n    ```\n\n    Pytest will then execute the test case defined by the `pytest.test()` function. You should see output indicating that the test passed or failed (if it failed, it will give you the details).\n\n**Example Output (if the test passes):**\n\n```\n============================= test session starts ==============================\nplatform darwin --- Unix shell used by test ---\nallelib --- Version 2.34.0\n pytest.main(): add(2, 3)\n=========================== test session, yayverted ==============================\n---------------------------------------------------------------------\nCandidates:\n- /path/to/your/file/test_add.py\n...\n================-------------------------------------------------------------------------------\nRock, Paper, Scissors,  # ... (more tests)\n==============================================================================================\n-----------------------------------------------------------------------------------------------\nTest Passed\n```\nv
                """.trimIndent(),
                "python",
                listOf<String>(
                    """
                        import pytest\n\ndef add(a, b):\n    return a + b\n\npytest.test(lambda: add(2, 3))\n
                    """.trimIndent(),
                )
            ),
            Arguments.of(
                """
                        Here are some example pytest tests for the `Calculator` class:\n\n```python\nimport pytest\nfrom calculator import Calculator\n\ndef test_add_two_positive_numbers():\n    calc = Calculator()\n    assert calc.add(2, 3) == 5\n\ndef test_add_one_positive_number_and_negative_number():\n    calc = Calculator()\n    assert calc.add(1, -2) == -1\n\ndef test_add_zero_to_all_numbers():\n    calc = Calculator()\n    assert calc.add(0, 2) == 2\n    assert calc.add(-2, 3) == 1\n    assert calc.add(0, 0) == 0\n\ndef test_add_negative_numbers():\n    calc = Calculator()\n    assert calc.add(-5, -3) == -8\n    assert calc.add(5, -3) == -8\n\ndef test_add_to_zero():\n    calc = Calculator()\n    assert calc.add(2, 0) == 2\n    assert calc.add(-3, 4) == 1\n\ndef test_invalid_input_types():\n    with pytest.raises(TypeError):\n        calc.add(\"a\", 2)\n\n    with pytest.raises(TypeError):\n        calc.add(2, \"b\")\n\ndef test_add_to_non_integer_input_types():\n    calc = Calculator()\n    with pytest.raises(TypeError):\n        calc.add(-3.5, 2)\n```\n\nThese tests cover various scenarios such as:\n\n- Adding two positive numbers\n- Adding one positive number and a negative number\n- Adding zero to all numbers (including both integer and float inputs)\n- Adding negative numbers\n- Adding to zero\n- Passing invalid input types (e.g., strings or non-integer inputs)\n- Passing non-integer input types (e.g., floats)
                    """.trimIndent(),
                "python",
                listOf<String>(
                    """
                            import pytest\nfrom calculator import Calculator\n\ndef test_add_two_positive_numbers():\n    calc = Calculator()\n    assert calc.add(2, 3) == 5\n\ndef test_add_one_positive_number_and_negative_number():\n    calc = Calculator()\n    assert calc.add(1, -2) == -1\n\ndef test_add_zero_to_all_numbers():\n    calc = Calculator()\n    assert calc.add(0, 2) == 2\n    assert calc.add(-2, 3) == 1\n    assert calc.add(0, 0) == 0\n\ndef test_add_negative_numbers():\n    calc = Calculator()\n    assert calc.add(-5, -3) == -8\n    assert calc.add(5, -3) == -8\n\ndef test_add_to_zero():\n    calc = Calculator()\n    assert calc.add(2, 0) == 2\n    assert calc.add(-3, 4) == 1\n\ndef test_invalid_input_types():\n    with pytest.raises(TypeError):\n        calc.add(\"a\", 2)\n\n    with pytest.raises(TypeError):\n        calc.add(2, \"b\")\n\ndef test_add_to_non_integer_input_types():\n    calc = Calculator()\n    with pytest.raises(TypeError):\n        calc.add(-3.5, 2)\n
                        """.trimIndent()
                )
            )
        )

    }


    @ParameterizedTest
    @MethodSource("responseAndListingProvider")
    fun extractListingFromLlmResponse(response: String, languageFilter: String, listings: List<String>) {
        val extractedCodes: Collection<String> = LlmParser.extractListingFromLlmResponse(response, languageFilter)
        assertEquals(listings.map { x -> x.trimIndent() }, extractedCodes.toList().map { x -> x.trimIndent() })
    }

}