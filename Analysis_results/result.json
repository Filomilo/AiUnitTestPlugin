{
  "runs": [
    {
      "failureReason": null,
      "llmModel": "none",
      "project": "JavaCalculator",
      "strategy": "Manual_Tests",
      "strategyDescription": "Manual test made already in project",
      "time": "2025-09-21T13:58:01.775662100Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "executionLogs": [
        "[INFO] Scanning for projects...\n[INFO] \n[INFO] --------< org.filomilo.AiTestGenerotorAnalisis:JavaCalculator >---------\n[INFO] Building JavaCalculator 1.0-SNAPSHOT\n[INFO]   from pom.xml\n[INFO] --------------------------------[ jar ]---------------------------------\n[WARNING] Parameter 'reports' is unknown for plugin 'jacoco-maven-plugin:0.8.12:report (report)'\n[INFO] \n[INFO] --- clean:3.2.0:clean (default-clean) @ JavaCalculator ---\n[INFO] Deleting F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\n[INFO] \n[INFO] --- jacoco:0.8.12:prepare-agent (default) @ JavaCalculator ---\n[INFO] argLine set to -javaagent:C:\\\\Users\\\\fboro\\\\.m2\\\\repository\\\\org\\\\jacoco\\\\org.jacoco.agent\\\\0.8.12\\\\org.jacoco.agent-0.8.12-runtime.jar=destfile=F:\\\\projects\\\\AiUnitTestPlugin\\\\tmp\\\\JavaCalculator\\\\target\\\\jacoco.exec\n[INFO] \n[INFO] --- resources:3.3.1:resources (default-resources) @ JavaCalculator ---\n[INFO] Copying 0 resource from src\\main\\resources to target\\classes\n[INFO] \n[INFO] --- compiler:3.13.0:compile (default-compile) @ JavaCalculator ---\n[INFO] Recompiling the module because of changed source code.\n[INFO] Compiling 1 source file with javac [debug target 17] to target\\classes\n[INFO] \n[INFO] --- resources:3.3.1:testResources (default-testResources) @ JavaCalculator ---\n[INFO] skip non existing resourceDirectory F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\src\\test\\resources\n[INFO] \n[INFO] --- compiler:3.13.0:testCompile (default-testCompile) @ JavaCalculator ---\n[INFO] Recompiling the module because of changed dependency.\n[INFO] Compiling 1 source file with javac [debug target 17] to target\\test-classes\n[INFO] \n[INFO] --- surefire:3.2.5:test (default-test) @ JavaCalculator ---\n[INFO] Using auto detected provider org.apache.maven.surefire.junitplatform.JUnitPlatformProvider\n[INFO] \n[INFO] -------------------------------------------------------\n[INFO]  T E S T S\n[INFO] -------------------------------------------------------\n[INFO] Running org.filomilo.AiTestGenerotorAnalisis.CalculatorTest\n[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.104 s -- in org.filomilo.AiTestGenerotorAnalisis.CalculatorTest\n[INFO] \n[INFO] Results:\n[INFO] \n[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] \n[INFO] --- jar:3.4.1:jar (default-jar) @ JavaCalculator ---\n[INFO] Building jar: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\JavaCalculator-1.0-SNAPSHOT.jar\n[INFO] \n[INFO] --- jacoco:0.8.12:report (report) @ JavaCalculator ---\n[INFO] Loading execution data file F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\jacoco.exec\n[INFO] Analyzed bundle 'JavaCalculator' with 1 classes\n[INFO] \n[INFO] --- install:3.1.2:install (default-install) @ JavaCalculator ---\n[INFO] Installing F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\pom.xml to C:\\Users\\fboro\\.m2\\repository\\org\\filomilo\\AiTestGenerotorAnalisis\\JavaCalculator\\1.0-SNAPSHOT\\JavaCalculator-1.0-SNAPSHOT.pom\n[INFO] Installing F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\JavaCalculator-1.0-SNAPSHOT.jar to C:\\Users\\fboro\\.m2\\repository\\org\\filomilo\\AiTestGenerotorAnalisis\\JavaCalculator\\1.0-SNAPSHOT\\JavaCalculator-1.0-SNAPSHOT.jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  4.658 s\n[INFO] Finished at: 2025-09-21T15:58:01+02:00\n[INFO] ------------------------------------------------------------------------\n"
      ],
      "promptResults": [],
      "duration": "PT7.790260800S",
      "report": {
        "CoveragePercent": 0.9605263
      }
    },
    {
      "failureReason": null,
      "llmModel": "none",
      "project": "PythonCalculator",
      "strategy": "Manual_Tests",
      "strategyDescription": "Manual test made already in project",
      "time": "2025-09-21T13:58:03.209923500Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "executionLogs": [
        "============================= test session starts =============================\nplatform win32 -- Python 3.12.2, pytest-8.3.5, pluggy-1.5.0\nrootdir: F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\nplugins: cov-6.2.1\ncollected 4 items\n\ntests\\test_Calculator.py FFFF                                            [100%]\n\n================================== FAILURES ===================================\n___________________________ TestCalculator.test_add ___________________________\n\nself = <tests.test_Calculator.TestCalculator testMethod=test_add>\n\n    def test_add(self):\n>       assert Calculator.add(1, 2) == 3\nE       TypeError: Calculator.add() missing 1 required positional argument: 'b'\n\ntests\\test_Calculator.py:8: TypeError\n_________________________ TestCalculator.test_divide __________________________\n\nself = <tests.test_Calculator.TestCalculator testMethod=test_divide>\n\n    def test_divide(self):\n>       assert (Calculator.divide(5, 2) == 2.5)\nE       TypeError: Calculator.divide() missing 1 required positional argument: 'b'\n\ntests\\test_Calculator.py:14: TypeError\n________________________ TestCalculator.test_multiply _________________________\n\nself = <tests.test_Calculator.TestCalculator testMethod=test_multiply>\n\n    def test_multiply(self):\n>       assert (Calculator.multiply(2, 3)) == 6\nE       TypeError: Calculator.multiply() missing 1 required positional argument: 'b'\n\ntests\\test_Calculator.py:12: TypeError\n________________________ TestCalculator.test_subtract _________________________\n\nself = <tests.test_Calculator.TestCalculator testMethod=test_subtract>\n\n    def test_subtract(self):\n>       assert Calculator.subtract(1, 2) == -1\nE       TypeError: Calculator.subtract() missing 1 required positional argument: 'b'\n\ntests\\test_Calculator.py:10: TypeError\n=============================== tests coverage ================================\n_______________ coverage: platform win32, python 3.12.2-final-0 _______________\n\nCoverage JSON written to file coverage.json\n=========================== short test summary info ===========================\nFAILED tests/test_Calculator.py::TestCalculator::test_add - TypeError: Calcul...\nFAILED tests/test_Calculator.py::TestCalculator::test_divide - TypeError: Cal...\nFAILED tests/test_Calculator.py::TestCalculator::test_multiply - TypeError: C...\nFAILED tests/test_Calculator.py::TestCalculator::test_subtract - TypeError: C...\n============================== 4 failed in 0.15s ==============================\n"
      ],
      "promptResults": [],
      "duration": "PT1.274086600S",
      "report": {
        "CoveragePercent": 0.45454544
      }
    },
    {
      "failureReason": null,
      "llmModel": "OllamaProcessors(model='llama2-uncensored', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:43:28.711389700Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "executionLogs": [
        "============================= test session starts =============================\nplatform win32 -- Python 3.12.2, pytest-8.3.5, pluggy-1.5.0\nrootdir: F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\nplugins: cov-6.2.1\ncollected 1 item / 2 errors\n\ntests\\test_classCalculator_2.py E                                        [100%]\n\n=================================== ERRORS ====================================\n_______________ ERROR collecting tests/test_classCalculator.py ________________\nC:\\Python312\\Lib\\site-packages\\_pytest\\python.py:493: in importtestmodule\n    mod = import_path(\nC:\\Python312\\Lib\\site-packages\\_pytest\\pathlib.py:587: in import_path\n    importlib.import_module(module_name)\nC:\\Python312\\Lib\\importlib\\__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:1387: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1360: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:1331: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:935: in _load_unlocked\n    ???\nC:\\Python312\\Lib\\site-packages\\_pytest\\assertion\\rewrite.py:176: in exec_module\n    source_stat, co = _rewrite_test(fn, self.config)\nC:\\Python312\\Lib\\site-packages\\_pytest\\assertion\\rewrite.py:356: in _rewrite_test\n    tree = ast.parse(source, filename=strfn)\nC:\\Python312\\Lib\\ast.py:52: in parse\n    return compile(source, filename, mode, flags,\nE     File \"F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\\tests\\test_classCalculator.py\", line 5\nE       ly():\nE           ^\nE   SyntaxError: invalid syntax\n______________ ERROR collecting tests/test_classCalculator_1.py _______________\ntests\\test_classCalculator_1.py:2: in <module>\n    python -m\nE   NameError: name 'python' is not defined\n________________________ ERROR at setup of test_divide ________________________\nfile F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\\tests\\test_classCalculator_2.py, line 2\n  def test_divide(a,b):\nE       fixture 'a' not found\n>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, monkeypatch, no_cover, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory\n>       use 'pytest --fixtures [testpath]' for help on them.\n\nF:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\\tests\\test_classCalculator_2.py:2\n=============================== tests coverage ================================\n_______________ coverage: platform win32, python 3.12.2-final-0 _______________\n\nCoverage JSON written to file coverage.json\n=========================== short test summary info ===========================\nERROR tests/test_classCalculator.py\nERROR tests/test_classCalculator_1.py - NameError: name 'python' is not defined\nERROR tests/test_classCalculator_2.py::test_divide\n============================== 3 errors in 0.34s ==============================\n"
      ],
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n 1. Tests for the add() method of Calculator class\\n\\n 1. add(4,5) should return 9\\n```\\nif self.add(4, 5) != 9:\\n raise Exception(\\\"Failed to add 4 and 5\\\")\\n```\\n2. add(0,5) should return 5\\n```\\nif self.add(0, 5) != 5:\\n raise Exception(\\\"Failed to add 0 and 5\\\")\\n```\\n3. add(-1,2) should return -1\\n```\\nif self.add(-1, 2) != -1:\\n raise Exception(\\\"Failed to add -1 and 2\\\")\\n```\\n4. add(5,7) should return 12\\n```\\nif self.add(5, 7) != 12:\\n raise Exception(\\\"Failed to add 5 and 7\\\")\\n``` \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Unittest Test Case for subtract() Function\\n\\ndef test_subtract():\\nclass Calculator:\\n def __init__(self):\\n self.num1 = 0\\n self.num2 = 0\\n\\n def subtract(self,a,b):\\n if a and b:\\n self.num1 -= b\\n else:\\n raise ValueError(\\\"Cannot subtract from zero\\\")\\n return self.num1\\n\\n# Create an instance of the Calculator class\\ncalculator = Calculator()\\n\\n# Run unittest test cases for subtract() function\\nassert calculator.subtract(2, 0) == 0\\nassert calculator.subtract(-3, 6) == -9\\nassert calculator.subtract('4', '5') == 1 \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "promptResults": [
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def multiply(self,a,b):\n       return a*b\n\n\n",
          "response": "To create unittest tests for the `Calculator` class and its method `multiply`, you can use Python's built-in `unittest` module. Here is an example test code that should pass:\\n```python\\nimport unittest\\nclass CalculatorTest(unittest.TestCase):\\n def setUp(self):\\n pass\\n \\n def tearDown(self):\\n pass\\n \\n def test_multiply():\\n self.assertEqual(Calculator().multiply(2,3),6) # ensure that `add` method returns the correct value\\n self.assertEqual(Calculator().multiply(5,7),35)\\n self.assertEqual(Calculator().multiply(10,2),20) # ensure that `add` method works with all input arguments\\n \\n if __name__ == '__main__':\\n unittest.main()\\n```\\nIn this code, we have imported the `unittest` module and created a new class called `CalculatorTest`. We then define three methods: `setUp`, which runs before each test case starts; `tearDown`, which runs after each test case ends; and `test_multiply`, which tests that the `multiply` method returns the correct values when given two numbers.\\nTo run this test code, you can simply save it as a Python file with a `.py` extension in your preferred directory (e.g., `CalculatorTest.py`), and then run the following command in your terminal or command prompt:\\n```python\\n$ python -m unittest CalculatorTest\\n```",
          "modelName": "Ollama-llama2-uncensored",
          "generationTime": "1m 53.744782500s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        },
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def divide(self,a,b):\n       if(b==0):\n           raise \"Cannot divide by zero\"\n       return a/b\n\n\n",
          "response": "Sure, here are some unittest tests for the `divide` function in the Calculator class:\\n```python\\nimport pytest\\n@pytest.mark.parametrize(\\\"a, b\\\", [([1, 2], 0), ([1, 3], 3)])\\ndef test_divide(a, b):\\n assert Calculator().divide(a[0], b) == a[0] / b\\n assert Calculator().divide([0, 2], 0) is None\\n assert Calculator().divide([1, 0], 1) == 1\\n assert Calculator().divide([-1, -2], -3) == -1 / -3\\n```",
          "modelName": "Ollama-llama2-uncensored",
          "generationTime": "58.053222100s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        },
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def add(self,a,b):\n       return a+b\n\n\n",
          "response": "1. Tests for the add() method of Calculator class\\n\\n 1. add(4,5) should return 9\\n```\\nif self.add(4, 5) != 9:\\n raise Exception(\\\"Failed to add 4 and 5\\\")\\n```\\n2. add(0,5) should return 5\\n```\\nif self.add(0, 5) != 5:\\n raise Exception(\\\"Failed to add 0 and 5\\\")\\n```\\n3. add(-1,2) should return -1\\n```\\nif self.add(-1, 2) != -1:\\n raise Exception(\\\"Failed to add -1 and 2\\\")\\n```\\n4. add(5,7) should return 12\\n```\\nif self.add(5, 7) != 12:\\n raise Exception(\\\"Failed to add 5 and 7\\\")\\n```",
          "modelName": "Ollama-llama2-uncensored",
          "generationTime": "1m 36.221284200s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        },
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def subtract(self,a,b):\n       return a-b\n\n\n",
          "response": "Unittest Test Case for subtract() Function\\n\\ndef test_subtract():\\nclass Calculator:\\n def __init__(self):\\n self.num1 = 0\\n self.num2 = 0\\n\\n def subtract(self,a,b):\\n if a and b:\\n self.num1 -= b\\n else:\\n raise ValueError(\\\"Cannot subtract from zero\\\")\\n return self.num1\\n\\n# Create an instance of the Calculator class\\ncalculator = Calculator()\\n\\n# Run unittest test cases for subtract() function\\nassert calculator.subtract(2, 0) == 0\\nassert calculator.subtract(-3, 6) == -9\\nassert calculator.subtract('4', '5') == 1",
          "modelName": "Ollama-llama2-uncensored",
          "generationTime": "56.397892500s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        }
      ],
      "generatedFiles": [
        {
          "name": "test_classCalculator.py",
          "children": [],
          "content": "import unittest\nclass CalculatorTest:\n    def tearDown(self):\n        pass\n        ly():\n        l(Calculator().multiply(2,3),6) # ensure that `add` method returns the correct value\n        l(Calculator().multiply(5,7),35)\n        l(Calculator().multiply(10,2),20) # ensure that `add` method works with all input arguments\n        '__main__':\n        \n\n    def test_multiply():\n        self.assertEqual(Calculator().multiply(2,3),6) # ensure that `add` method returns the correct value\n        l(Calculator().multiply(5,7),35)\n        l(Calculator().multiply(10,2),20) # ensure that `add` method works with all input arguments\n        '__main__':\n        \n\n\n\n"
        },
        {
          "name": "test_classCalculator_1.py",
          "children": [],
          "content": "\npython -m\n\nunittest\n\nCalculatorTest\n\n"
        },
        {
          "name": "test_classCalculator_2.py",
          "children": [],
          "content": "import pytest\ndef test_divide(a,b):\n    assert Calculator().divide(a[0], b) == a[0] / b\n    assert Calculator().divide([0, 2], 0) is None\n    assert Calculator().divide([1, 0], 1) == 1\n    assert Calculator().divide([-1, -2], -3) == -1 / -3\n\n\n"
        }
      ],
      "duration": "PT51M16.510397700S",
      "report": {
        "CoveragePercent": 0.0
      }
    },
    {
      "failureReason": null,
      "llmModel": "OllamaProcessors(model='starling-lm', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:43:06.027835800Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "executionLogs": [
        "============================= test session starts =============================\nplatform win32 -- Python 3.12.2, pytest-8.3.5, pluggy-1.5.0\nrootdir: F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\nplugins: cov-6.2.1\ncollected 0 items / 4 errors\n\n=================================== ERRORS ====================================\n_______________ ERROR collecting tests/test_classCalculator.py ________________\nC:\\Python312\\Lib\\site-packages\\_pytest\\python.py:493: in importtestmodule\n    mod = import_path(\nC:\\Python312\\Lib\\site-packages\\_pytest\\pathlib.py:587: in import_path\n    importlib.import_module(module_name)\nC:\\Python312\\Lib\\importlib\\__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:1387: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1360: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:1331: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:935: in _load_unlocked\n    ???\nC:\\Python312\\Lib\\site-packages\\_pytest\\assertion\\rewrite.py:176: in exec_module\n    source_stat, co = _rewrite_test(fn, self.config)\nC:\\Python312\\Lib\\site-packages\\_pytest\\assertion\\rewrite.py:356: in _rewrite_test\n    tree = ast.parse(source, filename=strfn)\nC:\\Python312\\Lib\\ast.py:52: in parse\n    return compile(source, filename, mode, flags,\nE     File \"F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\\tests\\test_classCalculator.py\", line 27\nE       d more test methods for other functions like multiply, divide, etc.\nE         ^^^^\nE   SyntaxError: invalid syntax\n______________ ERROR collecting tests/test_classCalculator_1.py _______________\nImportError while importing test module 'F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\\tests\\test_classCalculator_1.py'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\nC:\\Python312\\Lib\\importlib\\__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\ntests\\test_classCalculator_1.py:2: in <module>\n    from calculator import Calculator\nE   ModuleNotFoundError: No module named 'calculator'\n______________ ERROR collecting tests/test_classCalculator_2.py _______________\nImportError while importing test module 'F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\\tests\\test_classCalculator_2.py'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\nC:\\Python312\\Lib\\importlib\\__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\ntests\\test_classCalculator_2.py:2: in <module>\n    from calculator import Calculator\nE   ModuleNotFoundError: No module named 'calculator'\n______________ ERROR collecting tests/test_classCalculator_3.py _______________\nImportError while importing test module 'F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator\\tests\\test_classCalculator_3.py'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\nC:\\Python312\\Lib\\importlib\\__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\ntests\\test_classCalculator_3.py:2: in <module>\n    from your_module import Calculator\nE   ModuleNotFoundError: No module named 'your_module'\n=============================== tests coverage ================================\n_______________ coverage: platform win32, python 3.12.2-final-0 _______________\n\nCoverage JSON written to file coverage.json\n=========================== short test summary info ===========================\nERROR tests/test_classCalculator.py\nERROR tests/test_classCalculator_1.py\nERROR tests/test_classCalculator_2.py\nERROR tests/test_classCalculator_3.py\n============================== 4 errors in 0.40s ==============================\n"
      ],
      "promptResults": [
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def subtract(self,a,b):\n       return a-b\n\n\n",
          "response": "\\nHere are some unit test cases for the `Calculator` class and its `subtract` method using Python's built-in `unittest` module:\\n\\n```python\\nimport unittest\\nfrom calculator import Calculator\\n\\nclass TestCalculator(unittest.TestCase):\\n    def setUp(self):\\n        self.calc = Calculator()\\n\\n    def test_subtract_with_positive_numbers(self):\\n        result = self.calc.subtract(10, 5)\\n        self.assertEqual(result, 5, \\\"The subtraction of 10 and 5 should be 5\\\")\\n\\n    def test_subtract_with_negative_numbers(self):\\n        result = self.calc.subtract(-10, -5)\\n        self.assertEqual(result, -5, \\\"The subtraction of -10 and -5 should be -5\\\")\\n\\n    def test_subtract_zero(self):\\n        result = self.calc.subtract(10, 0)\\n        self.assertEqual(result, 10, \\\"The subtraction of 10 and 0 should be 10\\\")\\n\\n    def test_subtract_floats(self):\\n        result = self.calc.subtract(10.5, 5.2)\\n        self.assertEqual(result, 5.3, \\\"The subtraction of 10.5 and 5.2 should be 5.3\\\")\\n\\n    def test_subtract_large_numbers(self):\\n        result = self.calc.subtract(100000, 50000)\\n        self.assertEqual(result, 50000, \\\"The subtraction of 100000 and 50000 should be 50000\\\")\\n        \\n    def test_subtract_with_none_type_input(self):\\n        with self.assertRaises(TypeError):\\n            result = self.calc.subtract(10, None)\\n    \\nif __name__ == '__main__':\\n    unittest.main()\\n```\\n\\nHere, we've created a test case class `TestCalculator` that inherits from `unittest.TestCase`. Inside this class, we have defined several methods to test the `subtract` function of the `Calculator` class under various scenarios:\\n\\n1. `test_subtract_with_positive_numbers` checks if the subtraction of two positive numbers is correct.\\n2. `test_subtract_with_negative_numbers` checks if the subtraction of two negative numbers is correct.\\n3. `test_subtract_zero` checks if subtracting zero from any number returns the original number.\\n4. `test_subtract_floats` checks if the subtraction of two floating-point numbers is correct.\\n5. `test_subtract_large_numbers` checks if the subtraction of large numbers is correct.\\n6. `test_subtract_with_none_type_input` checks if the function raises a TypeError when provided with an unsupported input type (None in this case).",
          "modelName": "Ollama-starling-lm",
          "generationTime": "4m 15.540770700s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        },
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def divide(self,a,b):\n       if(b==0):\n           raise \"Cannot divide by zero\"\n       return a/b\n\n\n",
          "response": "\\nTo create unit tests for the Calculator class and its divide method, we can use Python's built-in unittest module. Here are some example test cases that check different scenarios:\\n\\n```python\\nimport unittest\\nfrom your_module import Calculator\\n\\nclass TestCalculator(unittest.TestCase):\\n    \\n    def setUp(self):\\n        self.calc = Calculator()\\n        \\n    def test_divide_with_positive_numbers(self):\\n        result = self.calc.divide(10, 2)\\n        self.assertEqual(result, 5)\\n        \\n    def test_divide_with_zero(self):\\n        with self.assertRaises(ZeroDivisionError):\\n            self.calc.divide(10, 0)\\n            \\n    def test_divide_with_negative_numbers(self):\\n        result = self.calc.divide(-10, -2)\\n        self.assertEqual(result, 5)\\n        \\n    def test_divide_with_same_number(self):\\n        result = self.calc.divide(10, 10)\\n        self.assertEqual(result, 1)\\n        \\n    def test_divide_with_float_numbers(self):\\n        result = self.calc.divide(10.5, 2.5)\\n        self.assertAlmostEqual(result, 4.2)\\n\\nif __name__ == '__main__':\\n    unittest.main()\\n```\\n\\nExplanation:\\n- `test_divide_with_positive_numbers` checks if the division of two positive numbers works correctly.\\n- `test_divide_with_zero` uses assertRaises to check if a ZeroDivisionError is raised when trying to divide by zero.\\n- `test_divide_with_negative_numbers` checks if the division of two negative numbers works correctly.\\n- `test_divide_with_same_number` checks if dividing a number by itself returns 1.\\n- `test_divide_with_float_numbers` uses assertAlmostEqual to check if the result is close enough when dealing with floating point numbers (due to potential precision errors).\\n\\nTo run these tests, you would save them in a file (e.g., test_calculator.py) and execute this file using python - you should see output indicating which tests passed or failed.",
          "modelName": "Ollama-starling-lm",
          "generationTime": "3m 5.099166100s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        },
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def add(self,a,b):\n       return a+b\n\n\n",
          "response": "\\nHere are some example unit tests for the Calculator class using Python's built-in `unittest` module:\\n\\n```python\\nimport unittest\\nfrom calculator import Calculator\\n\\nclass TestCalculator(unittest.TestCase):\\n\\n    def test_add(self):\\n        calc = Calculator()\\n        self.assertEqual(calc.add(2, 3), 5)\\n        self.assertEqual(calc.add(-1, 1), 0)\\n        self.assertEqual(calc.add(0, 0), 0)\\n\\n    def test_add_with_floats(self):\\n        calc = Calculator()\\n        self.assertAlmostEqual(calc.add(2.5, 3.5), 6)\\n        self.assertAlmostEqual(calc.add(-1.5, 1.5), 0)\\n\\n    def test_add_with_strings(self):\\n        calc = Calculator()\\n        with self.assertRaises(TypeError):\\n            calc.add('2', '3')\\n\\n    def test_subtract(self):\\n        calc = Calculator()\\n        self.assertEqual(calc.subtract(10, 5), 5)\\n        self.assertEqual(calc.subtract(-1, -1), 0)\\n        self.assertEqual(calc.subtract(0, 0), 0)\\n\\n    # Add more test methods for other functions like multiply, divide, etc.\\n\\nif __name__ == '__main__':\\n    unittest.main()\\n```\\n\\nIn this test suite, we have tests for the `add` method that check it works with integers, floats, and raises a TypeError when non-numeric types are passed. We also have a test for the hypothetical `subtract` method to illustrate how you could write similar tests for other methods in the Calculator class. \\n\\nTo run these tests, save them into a file (e.g., `test_calculator.py`) and then execute the file with Python:\\n\\n```bash\\npython test_calculator.py\\n```\\n\\nThe unittest module will automatically discover and run all methods that start with 'test' in your TestCalculator class, providing a report on which tests passed or failed.",
          "modelName": "Ollama-starling-lm",
          "generationTime": "5m 12.473027699s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        },
        {
          "prompt": "Create unittest tests for function class Calculator:\n    def multiply(self,a,b):\n       return a*b\n\n\n",
          "response": "\\nTo create unit tests for the `Calculator` class and its `multiply` method, we can use Python's built-in `unittest` module. Here are some example test cases to check if the multiplication is working correctly:\\n\\n```python\\nimport unittest\\nfrom calculator import Calculator\\n\\nclass TestCalculator(unittest.TestCase):\\n\\n    def setUp(self):\\n        self.calc = Calculator()\\n\\n    def test_multiply_positive_numbers(self):\\n        result = self.calc.multiply(3, 4)\\n        self.assertEqual(result, 12)\\n\\n    def test_multiply_negative_numbers(self):\\n        result = self.calc.multiply(-2, -3)\\n        self.assertEqual(result, 6)\\n\\n    def test_multiply_positive_and_negative_numbers(self):\\n        result = self.calc.multiply(-2, 3)\\n        self.assertEqual(result, -6)\\n\\n    def test_multiply_zero(self):\\n        result = self.calc.multiply(0, 5)\\n        self.assertEqual(result, 0)\\n\\n    def test_multiply_floats(self):\\n        result = self.calc.multiply(2.5, 3.5)\\n        self.assertAlmostEqual(result, 8.75)\\n\\nif __name__ == '__main__':\\n    unittest.main()\\n```\\n\\nIn these tests:\\n- `test_multiply_positive_numbers` checks if the multiplication of two positive numbers is correct.\\n- `test_multiply_negative_numbers` checks if the multiplication of two negative numbers is correct.\\n- `test_multiply_positive_and_negative_numbers` checks if the multiplication of a positive number and a negative number is correct.\\n- `test_multiply_zero` checks if multiplying by zero returns zero.\\n- `test_multiply_floats` checks if the multiplication of two floating-point numbers gives the expected result, using `assertAlmostEqual` for float comparison with a tolerance.\\n\\nTo run these tests, you can save them in a file (e.g., `test_calculator.py`) and execute it using `python test_calculator.py`. The `unittest` module will automatically discover and run the methods starting with `test_`. If any of the tests fail, the module will output a report indicating which test failed and why.",
          "modelName": "Ollama-starling-lm",
          "generationTime": "3m 17.168803700s",
          "deviceSpecification": {
            "ramBytes": 17112657920,
            "system": "Windows 11",
            "processor": {
              "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
              "physicalCores": 6,
              "logicalCores": 6
            },
            "gpu": [
              {
                "name": "NVIDIA GeForce GTX 1060 3GB",
                "VRamBytes": 3221225472
              }
            ]
          }
        }
      ],
      "generatedFiles": [
        {
          "name": "test_classCalculator.py",
          "children": [],
          "content": "import unittest\nfrom calculator import Calculator\nunittest.main()\n\nclass TestCalculator:\n    def test_add(self):\n        calc = Calculator()\n        self.assertEqual(calc.add(2, 3), 5)\n        self.assertEqual(calc.add(-1, 1), 0)\n        self.assertEqual(calc.add(0, 0), 0)\n\n    def test_add_with_floats(self):\n        calc = Calculator()\n        self.assertAlmostEqual(calc.add(2.5, 3.5), 6)\n        self.assertAlmostEqual(calc.add(-1.5, 1.5), 0)\n\n    def test_add_with_strings(self):\n        calc = Calculator()\n        with self.assertRaises(TypeError):\n            calc.add('2', '3')\n\n    def test_subtract(self):\n        calc = Calculator()\n        self.assertEqual(calc.subtract(10, 5), 5)\n        self.assertEqual(calc.subtract(-1, -1), 0)\n        self.assertEqual(calc.subtract(0, 0), 0)\n        d more test methods for other functions like multiply, divide, etc.\n\n\n\n"
        },
        {
          "name": "test_classCalculator_1.py",
          "children": [],
          "content": "import unittest\nfrom calculator import Calculator\nunittest.main()\n\nclass TestCalculator:\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_subtract_with_positive_numbers(self):\n        result = self.calc.subtract(10, 5)\n        self.assertEqual(result, 5, \"The subtraction of 10 and 5 should be 5\")\n\n    def test_subtract_with_negative_numbers(self):\n        result = self.calc.subtract(-10, -5)\n        self.assertEqual(result, -5, \"The subtraction of -10 and -5 should be -5\")\n\n    def test_subtract_zero(self):\n        result = self.calc.subtract(10, 0)\n        self.assertEqual(result, 10, \"The subtraction of 10 and 0 should be 10\")\n\n    def test_subtract_floats(self):\n        result = self.calc.subtract(10.5, 5.2)\n        self.assertEqual(result, 5.3, \"The subtraction of 10.5 and 5.2 should be 5.3\")\n\n    def test_subtract_large_numbers(self):\n        result = self.calc.subtract(100000, 50000)\n        self.assertEqual(result, 50000, \"The subtraction of 100000 and 50000 should be 50000\")\n\n    def test_subtract_with_none_type_input(self):\n        with self.assertRaises(TypeError):\n            result = self.calc.subtract(10, None)\n\n\n\n"
        },
        {
          "name": "test_classCalculator_2.py",
          "children": [],
          "content": "import unittest\nfrom calculator import Calculator\nunittest.main()\n\nclass TestCalculator:\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_multiply_positive_numbers(self):\n        result = self.calc.multiply(3, 4)\n        self.assertEqual(result, 12)\n\n    def test_multiply_negative_numbers(self):\n        result = self.calc.multiply(-2, -3)\n        self.assertEqual(result, 6)\n\n    def test_multiply_positive_and_negative_numbers(self):\n        result = self.calc.multiply(-2, 3)\n        self.assertEqual(result, -6)\n\n    def test_multiply_zero(self):\n        result = self.calc.multiply(0, 5)\n        self.assertEqual(result, 0)\n\n    def test_multiply_floats(self):\n        result = self.calc.multiply(2.5, 3.5)\n        self.assertAlmostEqual(result, 8.75)\n\n\n\n"
        },
        {
          "name": "test_classCalculator_3.py",
          "children": [],
          "content": "import unittest\nfrom your_module import Calculator\nunittest.main()\n\nclass TestCalculator:\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_divide_with_positive_numbers(self):\n        result = self.calc.divide(10, 2)\n        self.assertEqual(result, 5)\n\n    def test_divide_with_zero(self):\n        with self.assertRaises(ZeroDivisionError):\n            self.calc.divide(10, 0)\n\n    def test_divide_with_negative_numbers(self):\n        result = self.calc.divide(-10, -2)\n        self.assertEqual(result, 5)\n\n    def test_divide_with_same_number(self):\n        result = self.calc.divide(10, 10)\n        self.assertEqual(result, 1)\n\n    def test_divide_with_float_numbers(self):\n        result = self.calc.divide(10.5, 2.5)\n        self.assertAlmostEqual(result, 4.2)\n\n\n\n"
        }
      ],
      "duration": "PT1H18M54.405526601S",
      "report": {
        "CoveragePercent": 0.0
      }
    }
  ],
  "fails": [
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='llava', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-llava",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:57:51.454742200Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  import unittest\n\nclass TestCalculator(unittest.TestCase):\ndef test_add(self):\ncalc = Calculator()\nresult = calc.add(2, 3)\nself.assertEqual(result, 5)\n\nif **name** == '**main**':\nunittest.main()\n\n\nThis code defines a TestCalculator class that inherits from unittest.TestCase and contains a test method called test\\_add. The test\\_add method creates an instance of the Calculator class, calls its add method with arguments 2 and 3, and then asserts that the result is equal to 5. The if **name** == '**main**' block at the bottom runs the unittest.main() method to execute all test methods in the current module.  \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  ```\nimport unittest\nfrom calculator import Calculator\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        self.calculator = Calculator()\n\n    def test_subtract(self):\n        result = self.calculator.subtract(5, 3)\n        self.assertEqual(result, 2)\n\n    def test_subtract_zero(self):\n        result = self.calculator.subtract(10, 0)\n        self.assertEqual(result, 10)\n\n    def test_subtract_negative_numbers(self):\n        result = self.calculator.subtract(-5, -2)\n        self.assertEqual(result, -3)\n\nif __name__ == '__main__':\n    unittest.main()\n```\nThis code creates a test case for the `Calculator` class and its `subtract` method using the `unittest` module. The `setUp` method initializes an instance of the `Calculator` class, which is then used in the test methods. The first test method tests that the `subtract` method correctly subtracts two positive numbers, the second test method tests that the `subtract` method correctly subtracts a number from zero, and the third test method tests that the `subtract` method correctly subtracts negative numbers.  \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  import unittest\nfrom calculator import Calculator\n\nclass TestCalculator(unittest.TestCase):\n    def test_multiply(self):\n        calc = Calculator()\n        result = calc.multiply(2, 3)\n        self.assertEqual(result, 6)\n\n        result = calc.multiply(-2, -3)\n        self.assertEqual(result, 6)\n\n        result = calc.multiply(0, 1)\n        self.assertEqual(result, 0)\n\n        result = calc.multiply(1.5, 0.75)\n        self.assertAlmostEqual(result, 1.125, delta=0.1)\n\nif __name__ == '__main__':\n    unittest.main()  \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  Here are some sample unit tests for the `Calculator` class using the `unittest` module in Python:\n```python\nimport unittest\nfrom calculator import Calculator\n\nclass TestCalculator(unittest.TestCase):\n    def test_divide(self):\n        # Test positive division\n        calc = Calculator()\n        result = calc.divide(10, 2)\n        self.assertEqual(result, 5)\n        \n        # Test division by zero\n        with self.assertRaises(Exception):\n            calc.divide(10, 0)\n            \n        # Test negative division\n        result = calc.divide(-10, -2)\n        self.assertEqual(result, 5)\n        \n        # Test division with large numbers\n        result = calc.divide(1000000, 100000)\n        self.assertEqual(result, 1)\n```\nThese tests cover positive and negative division, as well as testing for the error message when attempting to divide by zero. You can run these tests using the `unittest` module by running:\n```bash\npython -m unittest test_calculator.py\n```\nMake sure to replace `test_calculator.py` with the actual name of your test file if it's different.  \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Error with reuqest [[OllamaGenerateRequest(model=phi4, prompt=Create unittest tests for function class Calculator:\n    def add(self,a,b):\n       return a+b\n\n\n, suffix=null, images=null, think=null, format=null, options=null, system=null, template=null, stream=false, raw=null, keep_alive=null)]]: Unexpected code Response{protocol=http/1.1, code=500, message=Internal Server Error, url=http://localhost:18502/api/generate} :: {\"error\":\"model requires more system memory (9.7 GiB) than is available (8.3 GiB)\"}"
      },
      "llmModel": "cache-Ollama-phi4",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:09:53.073392Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[]) using OllamaProcessors(model='llama3.2', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-llama3.2",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:00:49.737435200Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here is an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testAddPositiveNumbers() {\n        // Arrange\n        int a = 2;\n        int b = 3;\n        \n        // Act\n        int result = Calculator.add(a, b);\n        \n        // Assert\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testAddNegativeNumbers() {\n        // Arrange\n        int a = -2;\n        int b = -3;\n        \n        // Act\n        int result = Calculator.add(a, b);\n        \n        // Assert\n        assertEquals(-5, result);\n    }\n\n    @Test\n    public void testAddMixedNumbers() {\n        // Arrange\n        int a = 2;\n        int b = -3;\n        \n        // Act\n        int result = Calculator.add(a, b);\n        \n        // Assert\n        assertEquals(-1, result);\n    }\n\n    @Test\n    public void testAddZero() {\n        // Arrange\n        int a = 0;\n        int b = 5;\n        \n        // Act\n        int result = Calculator.add(a, b);\n        \n        // Assert\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testNullInput() {\n        // Expect\n        assertThrows(NullPointerException.class, () -> Calculator.add(null, 3));\n    }\n}\n```\n\nIn this example, we have written four tests:\n\n- `testAddPositiveNumbers`: Tests that the sum of two positive numbers is correct.\n- `testAddNegativeNumbers`: Tests that the sum of two negative numbers is correct.\n- `testAddMixedNumbers`: Tests that the sum of a positive and a negative number is correct.\n- `testAddZero`: Tests that the sum with zero as one of the inputs is correct.\n\nWe have also written a test for `nullInput` using JUnit's `assertThrows` method, which checks if calling the `add` method with `null` as an argument throws a `NullPointerException`.\n\nNote: The `@Test` annotation above each test method specifies that it should be executed by JUnit5 when running the tests. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you could write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    private final Calculator calculator = new Calculator();\n\n    @Test\n    public void testSubtract_TwoPositiveNumbers_ReturnsCorrectResult() {\n        int a = 5;\n        int b = 3;\n        int expectedResult = 2;\n        int actualResult = calculator.subtract(a, b);\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testSubtract_TwoNegativeNumbers_ReturnsCorrectResult() {\n        int a = -5;\n        int b = -3;\n        int expectedResult = -8;\n        int actualResult = calculator.subtract(a, b);\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testSubtract_PositiveAndNegativeNumber_ReturnsCorrectResult() {\n        int a = 5;\n        int b = -3;\n        int expectedResult = 8;\n        int actualResult = calculator.subtract(a, b);\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testSubtract_ZeroWithAnyNumber_ReturnsOriginalValue() {\n        int a = 0;\n        int b = 5;\n        int expectedResult = 5;\n        int actualResult = calculator.subtract(a, b);\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testSubtract_NegativeNumberWithZero_ReturnsNegativeOriginalValue() {\n        int a = -0; // Java doesn't allow zero negative integer\n        int b = 5;\n        int expectedResult = -5;\n        int actualResult = calculator.subtract(a, b);\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testSubtract_NullArgument_ThrowsNullPointerException() {\n        int a = null;\n        int b = 3;\n        assertThrows(NullPointerException.class, () -> calculator.subtract(a, b));\n    }\n}\n```\n\nIn this example, we have five tests:\n\n1. `testSubtract_TwoPositiveNumbers_ReturnsCorrectResult` - Tests that the subtraction of two positive numbers returns the correct result.\n2. `testSubtract_TwoNegativeNumbers_ReturnsCorrectResult` - Tests that the subtraction of two negative numbers returns the correct result.\n3. `testSubtract_PositiveAndNegativeNumber_ReturnsCorrectResult` - Tests that the subtraction of a positive number and a negative number returns the correct result.\n4. `testSubtract_ZeroWithAnyNumber_ReturnsOriginalValue` - Tests that the subtraction of zero with any number returns the original value.\n5. `testSubtract_NegativeNumberWithZero_ReturnsNegativeOriginalValue` - Tests that the subtraction of a negative number (with Java's unique behavior) and zero returns the correct result.\n6. `testSubtract_NullArgument_ThrowsNullPointerException` - Tests that passing null to the subtraction method throws a `NullPointerException`. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    void testMultiply_TwoPositiveNumbers_ReturnsProduct() {\n        // Arrange\n        Calculator calculator = new Calculator();\n        int a = 5;\n        int b = 3;\n\n        // Act\n        int result = calculator.multiply(a, b);\n\n        // Assert\n        assertEquals(15, result);\n    }\n\n    @Test\n    void testMultiply_TwoNegativeNumbers_ReturnsPositiveProduct() {\n        // Arrange\n        Calculator calculator = new Calculator();\n        int a = -5;\n        int b = -3;\n\n        // Act\n        int result = calculator.multiply(a, b);\n\n        // Assert\n        assertEquals(15, result);\n    }\n\n    @Test\n    void testMultiply_OnePositiveOneNegativeNumber_ReturnsPositiveResult() {\n        // Arrange\n        Calculator calculator = new Calculator();\n        int a = 5;\n        int b = -3;\n\n        // Act\n        int result = calculator.multiply(a, b);\n\n        // Assert\n        assertEquals(-15, result);\n    }\n\n    @Test\n    void testMultiply_Zero_ReturnsZero() {\n        // Arrange\n        Calculator calculator = new Calculator();\n        int a = 0;\n        int b = 10;\n\n        // Act\n        int result = calculator.multiply(a, b);\n\n        // Assert\n        assertEquals(0, result);\n    }\n\n    @Test\n    void testMultiply_NullValues_ThrowsNullPointerException() {\n        // Arrange\n        Calculator calculator = new Calculator();\n\n        // Act and Assert\n        assertThrows(NullPointerException.class, () -> calculator.multiply(null, 10));\n    }\n}\n```\n\nThis class includes five tests to cover different scenarios:\n\n1.  `testMultiply_TwoPositiveNumbers_ReturnsProduct`: Tests that multiplying two positive numbers returns the correct product.\n2.  `testMultiply_TwoNegativeNumbers_ReturnsPositiveProduct`: Verifies that multiplying two negative numbers also returns a positive result.\n3.  `testMultiply_OnePositiveOneNegativeNumber_ReturnsPositiveResult`: Checks that multiplying a positive number with a negative number gives the expected result.\n4.  `testMultiply_Zero_ReturnsZero`: Confirms that multiplying any number by zero yields zero.\n5.  `testMultiply_NullValues_ThrowsNullPointerException`: Tests that passing null values to the multiplication method throws a NullPointerException.\n\nNote: Make sure you're using JUnit 5 (Jupiter) API for writing these tests, as it provides better functionality and support compared to previous versions. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class CalculatorTest {\n\n    private Calculator calculator = new Calculator();\n\n    @Test\n    public void testDivide() {\n        int a = 10;\n        int b = 2;\n        int expected = 5;\n        int actual = calculator.divide(a, b);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testDivideByZero() {\n        int a = 10;\n        int b = 0;\n        ArithmeticException exception = assertThrows(ArithmeticException.class,\n                () -> calculator.divide(a, b));\n        assertEquals(\"Divide by zero\", exception.getMessage());\n    }\n}\n```\n\nHowever, the `Calculator` class is not thread-safe, as it uses a static variable to store its instance. In JUnit5, each test method runs independently and any state that's maintained across tests should be reset after each test.\n\nTo make the `Calculator` class more test-friendly, you could consider making it a singleton or using dependency injection.\n\nHere is an example of how you can refactor the `Calculator` class:\n\n```java\npublic class Calculator {\n    private Calculator() {}\n\n    public static final Calculator INSTANCE = new Calculator();\n\n    public int divide(int a, int b) {\n        if (b == 0)\n            throw new ArithmeticException(\"Divide by zero\");\n        return a / b;\n    }\n}\n```\n\nOr:\n\n```java\npublic class Calculator {\n    private final Calculator() {}\n\n    @Inject\n    public Calculator(Calculator calculator) {\n        this = calculator;\n    }\n\n    public int divide(int a, int b) {\n        if (b == 0)\n            throw new ArithmeticException(\"Divide by zero\");\n        return a / b;\n    }\n}\n```\n\nAnd here's how you can modify the test to use dependency injection:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class CalculatorTest {\n\n    private Calculator calculator;\n\n    @BeforeEach\n    public void setUp() {\n        calculator = new Calculator();\n    }\n\n    @Test\n    public void testDivide() {\n        int a = 10;\n        int b = 2;\n        int expected = 5;\n        assertEquals(expected, calculator.divide(a, b));\n    }\n\n    @Test\n    public void testDivideByZero() {\n        int a = 10;\n        int b = 0;\n        ArithmeticException exception = assertThrows(ArithmeticException.class,\n                () -> calculator.divide(a, b));\n        assertEquals(\"Divide by zero\", exception.getMessage());\n    }\n}\n```\n\nIn this refactored version, the `Calculator` class is no longer a singleton and each test runs independently. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testMultiply_TwoPositiveNumbers_ReturnsCorrectProduct() {\n        Calculator calculator = new Calculator();\n        float a = 2.0f;\n        float b = 3.0f;\n        float expectedResult = 6.0f;\n        float actualResult = calculator.multiply(a, b);\n        \n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testMultiply_TwoNegativeNumbers_ReturnsCorrectProduct() {\n        Calculator calculator = new Calculator();\n        float a = -2.0f;\n        float b = -3.0f;\n        float expectedResult = 6.0f;\n        float actualResult = calculator.multiply(a, b);\n        \n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testMultiply_MixedPositiveNegativeNumbers_ReturnsCorrectProduct() {\n        Calculator calculator = new Calculator();\n        float a = -2.0f;\n        float b = 3.0f;\n        float expectedResult = -6.0f;\n        float actualResult = calculator.multiply(a, b);\n        \n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testMultiply_Zero_ReturnsZero() {\n        Calculator calculator = new Calculator();\n        float a = 0.0f;\n        float b = 3.0f;\n        float expectedResult = 0.0f;\n        float actualResult = calculator.multiply(a, b);\n        \n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    public void testMultiply_NullValue_ThrowsNullPointerException() {\n        Calculator calculator = new Calculator();\n        float a = null;\n        float b = 3.0f;\n        \n        assertThrows(NullPointerException.class, () -> calculator.multiply(a, b));\n    }\n}\n```\n\nThese tests cover the following scenarios:\n\n*   Multiplying two positive numbers\n*   Multiplying two negative numbers\n*   Multiplying a mixed positive-negative number pair\n*   Multiplying by zero\n*   Passing a null value to the `multiply` method \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testDivideByZero() {\n        // Arrange\n        float a = 10f;\n        float b = 0f;\n\n        // Act & Assert\n        assertThrows(ArithmeticException.class, () -> Calculator.divide(a, b));\n    }\n\n    @Test\n    public void testDivideNonZero() {\n        // Arrange\n        float a = 10f;\n        float b = 2f;\n\n        // Act\n        float result = Calculator.divide(a, b);\n\n        // Assert\n        assertEquals(5f, result);\n    }\n}\n```\n\nIn this example, we have two tests:\n\n- `testDivideByZero`: This test checks if the function correctly throws an `ArithmeticException` when trying to divide by zero.\n- `testDivideNonZero`: This test checks if the function correctly returns the expected result for a division operation where both numbers are non-zero.\n\nNote: The actual values of `a` and `b` can be any valid numbers, but in this case, we're choosing simple ones to make the tests easier to understand. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you could write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testAddPositiveNumbers() {\n        Calculator calculator = new Calculator();\n        float result = calculator.add(10.0f, 5.0f);\n        assertEquals(15.0f, result);\n    }\n\n    @Test\n    public void testAddNegativeNumbers() {\n        Calculator calculator = new Calculator();\n        float result = calculator.add(-1.0f, -2.0f);\n        assertEquals(-3.0f, result);\n    }\n\n    @Test\n    public void testAddMixedNumbers() {\n        Calculator calculator = new Calculator();\n        float result = calculator.add(5.0f, -2.0f);\n        assertEquals(3.0f, result);\n    }\n\n    @Test\n    public void testAddZero() {\n        Calculator calculator = new Calculator();\n        float result = calculator.add(0.0f, 0.0f);\n        assertEquals(0.0f, result);\n    }\n\n    @Test\n    public void testAddFloatArray() {\n        Calculator calculator = new Calculator();\n        float[] numbers = {1.0f, 2.0f};\n        float result = calculator.add(numbers[0], numbers[1]);\n        assertEquals(3.0f, result);\n    }\n\n    @Test\n    public void testAddNullArguments() {\n        Calculator calculator = new Calculator();\n        try {\n            calculator.add(null, 5.0f);\n            fail(\"Expected NullPointerException\");\n        } catch (NullPointerException e) {\n            // Expected exception\n        }\n    }\n}\n```\n\nHowever, in JUnit5, you would typically use the `@Param` annotation with the `ValueSource` class to run multiple tests in a single method:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testAddNumbers(@ValueSource(floats = {1.0f, 2.0f}) float numberA,\n                             @ValueSource(floats = {3.0f, 4.0f}) float numberB) {\n        Calculator calculator = new Calculator();\n        float result = calculator.add(numberA, numberB);\n        assertEquals(numberA + numberB, result);\n    }\n}\n```\n\nThis way, you can test all possible combinations of inputs with just one method.\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testAddNumbers(@ValueSource(floats = {1.0f, 2.0f}) float numberA,\n                             @ValueSource(floats = {-3.0f, -4.0f}) float numberB) {\n        Calculator calculator = new Calculator();\n        float result = calculator.add(numberA, numberB);\n        assertEquals(numberA + numberB, result);\n    }\n\n    // ...\n}\n```\n\nAlso note that `@Test` method should be annotated with `@RepeatedTest(10)` if you want to run the same test multiple times (e.g., for testing different floating point precision levels) \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testSubtract_ReturnsExpectedResult() {\n        Calculator calculator = new Calculator();\n        float result = calculator.subtract(10.0f, 2.0f);\n        assertEquals(8.0f, result);\n    }\n\n    @Test\n    public void testSubtract_NegativeNumbers() {\n        Calculator calculator = new Calculator();\n        float result = calculator.subtract(-1.5f, -2.5f);\n        assertEquals(-4.0f, result);\n    }\n\n    @Test\n    public void testSubtract_Zero() {\n        Calculator calculator = new Calculator();\n        float result = calculator.subtract(10.0f, 0.0f);\n        assertEquals(10.0f, result);\n    }\n\n    @Test\n    public void testSubtract_NegativeZero() {\n        Calculator calculator = new Calculator();\n        float result = calculator.subtract(-1.5f, -0.5f);\n        assertEquals(-1.0f, result);\n    }\n\n    @Test\n    public void testSubtract_Overflow() {\n        Calculator calculator = new Calculator();\n        try {\n            calculator.subtract(Float.MAX_VALUE, 2.0f);\n            assert false;\n        } catch (ArithmeticException e) {\n            // expected exception\n        }\n    }\n}\n```\n\nNote that we are using `ArithmeticException` as a custom exception to handle the overflow case.\n\nTo make this test more robust, you can also use `@TestFactory` to generate multiple tests for different inputs. Here's an example:\n\n```java\nimport org.junit.jupiter.api.TestFactory;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @TestFactory\n    public Iterable<Test> generateSubtractTests() {\n        return Arrays.asList(\n                Arrays.asList(10.0f, 2.0f),\n                Arrays.asList(-1.5f, -2.5f),\n                Arrays.asList(10.0f, 0.0f),\n                Arrays.asList(-1.5f, -0.5f),\n                Float.MAX_VALUE / 2.0f\n        ).stream()\n                .map(a -> () -> {\n                    Calculator calculator = new Calculator();\n                    return () -> {\n                        try {\n                            return calculator.subtract(a[0], a[1]);\n                        } catch (ArithmeticException e) {\n                            assert false;\n                        }\n                        return 0;\n                    };\n                })\n                .filter(Test::isValidTest)\n                .toArray(Test[]::new);\n    }\n\n    private static boolean isValidTest(Test test) {\n        try {\n            Calculator calculator = new Calculator();\n            calculator.subtract(test.a[0], test.a[1]);\n        } catch (ArithmeticException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public interface Test {\n        void run() throws Exception;\n    }\n}\n```\n\nThis will generate multiple tests with different input combinations. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here is an example of how you could write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testMultiply_TwoPositiveNumbers_ReturnsCorrectProduct() {\n        Calculator calculator = new Calculator();\n        double result = calculator.multiply(2, 3);\n        assertEquals(6.0, result, 1e-9);\n    }\n\n    @Test\n    public void testMultiply_OneNegativeAndOnePositiveNumber_ReturnsCorrectProductWithSign() {\n        Calculator calculator = new Calculator();\n        double result = calculator.multiply(-2, 3);\n        assertEquals(-6.0, result, 1e-9);\n    }\n\n    @Test\n    public void testMultiply_TwoNegativeNumbers_ReturnsCorrectProductWithSign() {\n        Calculator calculator = new Calculator();\n        double result = calculator.multiply(-2, -3);\n        assertEquals(6.0, result, 1e-9);\n    }\n\n    @Test\n    public void testMultiply_ZeroAndNonZeroNumber_ReturnsCorrectResult() {\n        Calculator calculator = new Calculator();\n        double result = calculator.multiply(0, 3);\n        assertEquals(0.0, result, 1e-9);\n    }\n\n    @Test\n    public void testMultiplyZeroAndZero_ReturnsCorrectResult() {\n        Calculator calculator = new Calculator();\n        double result = calculator.multiply(0, 0);\n        assertEquals(0.0, result, 1e-9);\n    }\n}\n```\n\nIn the above code:\n\n*   We use `@Test` annotation to mark each test method.\n*   Each test method tests a different scenario using the `Calculator` class.\n*   We use `assertEquals` from JUnit5 to verify if the calculated result matches the expected value.\n*   The `1e-9` in the `assertEquals` method represents a small delta for floating-point comparisons, as multiplication can lead to slight rounding errors. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you could write JUnit 5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class CalculatorTest {\n\n    private final Calculator calculator = new Calculator();\n\n    @Test\n    void testDivide() {\n        double result = calculator.divide(10.0, 2.0);\n        assertEquals(5.0, result);\n    }\n\n    @Test\n    void testDivideByZeroThrowsArithmeticException() {\n        assertThrows(ArithmeticException.class, () -> calculator.divide(10.0, 0.0));\n    }\n\n    @Test\n    void testDivideNegativeNumbers() {\n        double result = calculator.divide(-10.0, -2.0);\n        assertEquals(5.0, result);\n    }\n\n    @Test\n    void testDivideVeryLargeAndSmallNumbers() {\n        double result = calculator.divide(1000000.0, 10.0);\n        assertEquals(100000.0, result);\n    }\n}\n```\n\nIn this example, we're testing the following scenarios:\n\n- `testDivide`: Tests that dividing two positive numbers gives a correct result.\n- `testDivideByZeroThrowsArithmeticException`: Tests that throwing an `ArithmeticException` when trying to divide by zero occurs as expected.\n- `testDivideNegativeNumbers`: Tests that dividing two negative numbers also works correctly.\n- `testDivideVeryLargeAndSmallNumbers`: Tests that the function handles very large and small inputs correctly.\n\nNote: The `assertEquals(5.0, result);` line is used to check if the actual result is equal to the expected one, but it's not exactly checking for precision. In a real-world scenario, you would want to check for precision using a delta value or similar approach to account for floating-point arithmetic issues.\n\nAlso, `ArithmeticException` is a checked exception in Java. If you're using JUnit 5, you can suppress the warning by adding the `@ SuppressWarnings` annotation:\n\n```java\n@Test\nvoid testDivideByZeroThrowsArithmeticException() {\n    @SuppressWarnings(\"all\")\n    assertThrows(ArithmeticException.class, () -> calculator.divide(10.0, 0.0));\n}\n```\n\nHowever, it's usually better to handle checked exceptions properly in a real-world application instead of suppressing the warning. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    private Calculator calculator = new Calculator();\n\n    @Test\n    public void testAdd() {\n        // Given\n        double a = 10.0;\n        double b = 5.0;\n\n        // When\n        double result = calculator.add(a, b);\n\n        // Then\n        assertEquals(15.0, result);\n    }\n\n    @Test\n    public void testAddNegativeNumbers() {\n        // Given\n        double a = -3.0;\n        double b = -2.0;\n\n        // When\n        double result = calculator.add(a, b);\n\n        // Then\n        assertEquals(-5.0, result);\n    }\n\n    @Test\n    public void testAddZero() {\n        // Given\n        double a = 10.0;\n        double b = 0.0;\n\n        // When\n        double result = calculator.add(a, b);\n\n        // Then\n        assertEquals(10.0, result);\n    }\n\n    @Test\n    public void testNullValues() {\n        try {\n            // Given\n            Double a = null;\n            Double b = 5.0;\n\n            // When\n            calculator.add(a, b);\n\n            // This should fail because add() method expects doubles, not nullable doubles.\n            // If you want to allow nullable doubles, consider using Optional class.\n\n            assert false;\n        } catch (NullPointerException e) {\n            // Expected exception.\n        }\n    }\n\n    @Test\n    public void testAddVeryLargeNumbers() {\n        // Given\n        double a = 10000000.0;\n        double b = 5000000.0;\n\n        // When\n        double result = calculator.add(a, b);\n\n        // Then\n        assertEquals(15000000.0, result);\n    }\n}\n```\n\nNote that the `Calculator` class should be modified to throw a `NullPointerException` if it receives a `null` value:\n\n```java\npublic class Calculator {\n    public static double add(double a, double b) {\n        if (a == null || b == null) {\n            throw new NullPointerException(\"add() expects non-null values\");\n        }\n        return a + b;\n    }\n}\n```\n\nThis way, the `nullValues()` test will correctly fail. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here is an example of how you can write JUnit5 tests for the `Calculator` class:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    private Calculator calculator = new Calculator();\n\n    @Test\n    public void testSubtract_SimpleCase_ReturnsCorrectValue() {\n        // Arrange\n        double a = 10.0;\n        double b = 5.0;\n\n        // Act\n        double result = calculator.subtract(a, b);\n\n        // Assert\n        assertEquals(5.0, result, 1e-6); // Using delta method for floating point comparison\n    }\n\n    @Test\n    public void testSubtract_NegativeNumbers_ReturnsCorrectValue() {\n        // Arrange\n        double a = -10.0;\n        double b = -5.0;\n\n        // Act\n        double result = calculator.subtract(a, b);\n\n        // Assert\n        assertEquals(5.0, result, 1e-6);\n    }\n\n    @Test\n    public void testSubtract Zero_ReturnsCorrectValue() {\n        // Arrange\n        double a = 10.0;\n        double b = 0.0;\n\n        // Act\n        double result = calculator.subtract(a, b);\n\n        // Assert\n        assertEquals(10.0, result, 1e-6);\n    }\n\n    @Test\n    public void testSubtract_DivideByZero_ReturnsNaN() {\n        // Arrange\n        double a = 10.0;\n        double b = 0.0;\n\n        // Act and Assert\n        assertEquals(Double.NaN, calculator.subtract(a, b), 1e-6);\n    }\n\n    @Test\n    public void testSubtract_InvalidInput_ReturnsNaN() {\n        // Arrange\n        double a = Double.POSITIVE_INFINITY;\n        double b = -5.0;\n\n        // Act and Assert\n        assertEquals(Double.NaN, calculator.subtract(a, b), 1e-6);\n    }\n}\n```\n\nIn these tests, we're covering various scenarios such as:\n\n- Simple case with positive numbers\n- Case with negative numbers\n- Case with zero\n- Case where one of the inputs is NaN (Not a Number)\n- Case where either input is infinity\n\nWe're using the `assertEquals` method to verify that the result matches the expected value, and we're passing an optional delta value to account for floating point precision issues. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='mistral', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-mistral",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:42:21.149547Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  To create unit tests for the `Calculator` class with the provided `add` method using Python's built-in `unittest` module, you can follow the steps below:\n\n1. First, let's define the Calculator class:\n\n```python\nclass Calculator:\n    def add(self, a, b):\n        return a + b\n```\n\n2. Now, create a test case for the Calculator class using `unittest`.\n\n```python\nimport unittest\nfrom your_module import Calculator  # replace \"your_module\" with the actual name of the module where Calculator is defined\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        self.calculator = Calculator()\n\n    def test_addition(self):\n        result = self.calculator.add(2, 3)\n        self.assertEqual(result, 5)\n\n    def test_negative_numbers(self):\n        result = self.calculator.add(-1, -2)\n        self.assertEqual(result, -3)\n\n    def test_zero(self):\n        result = self.calculator.add(0, 5)\n        self.assertEqual(result, 5)\n\nif __name__ == '__main__':\n    unittest.main()\n``` \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  To create unit tests for the `Calculator` class with its `subtract` method using Python's built-in `unittest` module, you can follow the example below.\n\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        self.calculator = Calculator()  # Initialize an instance of the Calculator class\n\n    def test_subtract(self):\n        # Test positive numbers\n        self.assertEqual(self.calculator.subtract(5,2),3)\n        self.assertEqual(self.calculator.subtract(10,7),3)\n\n        # Test negative numbers\n        self.assertEqual(self.calculator.subtract(-5,-2),3)\n        self.assertEqual(self.calculator.subtract(-10,-7),3)\n\n        # Test zero\n        self.assertEqual(self.calculator.subtract(0,4),-4)\n        self.assertEqual(self.calculator.subtract(4,0),4)\n\n    def tearDown(self):\n        pass  # No additional cleanup needed in this case\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis code creates a test case named `TestCalculator`, which contains one test method called `test_subtract`. In this example, I've tested the `subtract` method with positive, negative numbers, and zero. You can add more test cases to validate other scenarios as needed for your application.\n\nTo run the tests:\n\n1. Save the above code in a file named `test_calculator.py`.\n2. Run the test script from the command line using `python test_calculator.py`. The output should show whether each test has passed or failed, and the test runner will display any error messages if any tests fail. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  To create unit tests for the `Calculator` class with the `multiply` method using Python's built-in `unittest` module, you can write a test case that includes several test methods. Here's an example of how you could structure your test code:\n\n```python\nimport unittest\nfrom calculator import Calculator\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        self.calculator = Calculator()\n\n    def test_multiply(self):\n        # Test with positive numbers\n        result = self.calculator.multiply(2, 3)\n        self.assertEqual(result, 6)\n\n        # Test with zero as one of the operands\n        result = self.calculator.multiply(0, 5)\n        self.assertEqual(result, 0)\n\n        # Test with negative numbers\n        result = self.calculator.multiply(-2, -3)\n        self.assertEqual(result, 6)\n\n    def test_raises_error(self):\n        # Test if an error is raised when dividing by zero (since your multiply method doesn't support division)\n        with self.assertRaises(TypeError):\n            self.calculator.multiply(2, 0)\n\ndef main():\n    unittest.main()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nIn this example, `TestCalculator` is the test case class which contains two test methods:\n- `test_multiply` tests the multiply method with positive numbers and zero as well as negative numbers.\n- `test_raises_error` tests if an error is raised when trying to use the multiply method with a division by zero (since your multiply function doesn't support it). \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  To create unit tests for the `Calculator` class and its `divide` method, you can use Python's built-in `unittest` module. Here is an example of how you could write the unit tests:\n\n```python\nimport unittest\nclass TestCalculator(unittest.TestCase):\n def setUp(self):\n self.calculator = Calculator()\n\n def test_divide_positive_numbers(self):\n self.assertAlmostEqual(self.calculator.divide(10, 2), 5.0)\n self.assertAlmostEqual(self.calculator.divide(24, 3), 8.0)\n self.assertAlmostEqual(self.calculator.divide(100, 10), 10.0)\n\n def test_divide_negative_numbers(self):\n self.assertAlmostEqual(self.calculator.divide(-10, -2), 5.0)\n self.assertAlmostEqual(self.calculator.divide(-24, -3), 8.0)\n self.assertAlmostEqual(self.calculator.divide(-100, -10), 10.0)\n\n def test_cannot_divide_by_zero(self):\n with self.assertRaises(Exception):\n self.calculator.divide(2, 0)\n\nif __name__ == '__main__':\n unittest.main()\n```\n\nIn this example, the `TestCalculator` class contains three test methods:\n\n* `test_divide_positive_numbers` tests that the calculator can divide positive numbers correctly.\n* `test_divide_negative_numbers` tests that the calculator can divide negative numbers correctly.\n* `test_cannot_divide_by_zero` tests that an exception is raised when trying to divide by zero, as per the behavior of the original function.\n\nEach test method uses either the `assertAlmostEqual` or `assertRaises` methods from `unittest.TestCase` to verify that the expected output matches the actual output returned by the calculator's `divide` method.\n\nYou can then run these tests using the command `python -m unittest test_calculator.py`. The tests will pass if the `Calculator` class correctly implements the `divide` method, and fail otherwise. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Error with reuqest [[OllamaGenerateRequest(model=deepseek-r1, prompt=Create Junit5 tests for function public class Calculator{public static int divide(inta,intb){\n        if (b == 0)\n            throw new ArithmeticException(\"Divide by zero\");\n        return a / b;\n    \n}\n}\n, suffix=null, images=null, think=null, format=null, options=null, system=null, template=null, stream=false, raw=null, keep_alive=null)]]: timeout"
      },
      "llmModel": "cache-Ollama-deepseek-r1",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T10:55:19.493547500Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n <think>\nWe are going to create JUnit 5 tests for the subtract method in the Calculator class.\n The method is static and takes two integers (inta, intb) and returns their difference.\n\n We need to test:\n 1. Basic subtraction with positive numbers.\n 2. Subtraction when the first number is negative and the second is positive.\n 3. Subtraction when the first number is positive and the second is negative (result should be a sum).\n 4. Subtraction of two zeros.\n 5. Large numbers to check for overflow/underflow? But since we are using int, it's limited by integer range.\n\n However, note that JUnit 5 doesn't require testing every edge case but we can test some critical ones.\n\n Let's create tests in the CalculatorTest class.\n\n We'll use:\n - @Test for each test\n - Assertions from org.junit.jupiter.api.Assertions\n\n Steps:\n 1. Create a new class named Calculator.\n    But note: the provided code is incomplete (missing closing brace and semicolon) but we assume it's fixed.\n\n Let me write the Calculator class first to be complete:\n\n public class Calculator {\n     public static int subtract(int a, int b) {\n         return a - b;\n     }\n }\n\n Now, let's create the test class.\n</think>\nHere are JUnit 5 tests for the `subtract` method in the `Calculator` class. These tests cover various scenarios including positive numbers, negative results, and edge cases like Integer.MAX_VALUE:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class CalculatorTest {\n\n    @Test\n    void subtract_TwoPositiveNumbers_ReturnsCorrectDifference() {\n        int result = Calculator.subtract(10, 5);\n        assertThat(result).isEqualTo(5);\n    }\n\n    @Test\n    void subtract_ZeroAndNegativeNumber_ReturnsNegativeResult() {\n        int result = Calculator.subtract(3, -7);\n        assertThat(result).isEqualTo(10); // Demonstrates handling of negative inputs\n    }\n\n    @Test\n    void subtract_TwoNegativeNumbers_ReturnsCorrectDifference() {\n        int result = Calculator.subtract(-5, -3);\n        assertThat(result).isEqualTo(-2);\n    }\n\n    @Test\n    void subtract_IntegerMaxValueAndOne_ReturnsOverflowResult() {\n        int maxValue = Integer.MAX_VALUE;\n        int result = Calculator.subtract(maxValue, 1);\n        // Overflow wraps around to negative (Integer.MIN_VALUE) according to two's complement behavior.\n        assertThat(result).isEqualTo(Integer.MIN_VALUE); \n    }\n\n    @Test\n    void subtract_IntegerMinValueAndNegative_ReturnsOverflowResult() {\n        int minValue = Integer.MIN_VALUE;\n        int result = Calculator.subtract(minValue, -1);\n        // Underflow wraps around to positive (Integer.MAX_VALUE) according to two's complement behavior.\n        assertThat(result).isEqualTo(Integer.MAX_VALUE); \n    }\n}\n```\n\n**Key Points:**\n- **Assertions**: Uses AssertJ for concise and expressive assertions (`assertThat(...).isEqualTo(...)`)\n- **Edge Cases**: Covers `MAX_VALUE` subtraction leading to overflow (resulting in `MIN_VALUE`) and `MIN_VALUE` subtraction causing underflow (resulting in `MAX_VALUE`)\n- **Negative Inputs**: Tests scenarios where inputs include negative numbers, ensuring the method handles them correctly \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n <think>\nWe are testing the multiply method in the Calculator class.\n The method is static and takes two integers, returns their product.\n\n We need to consider:\n 1. Positive numbers (normal case)\n 2. Negative numbers (negative times negative gives positive, negative times positive gives negative)\n 3. Zero inputs\n\n Also, we should check for overflow? Since int can be from -2^31 to 2^31-1.\n However, the problem does not specify behavior on overflow, but let's note that:\n If a and b are both Integer.MAX_VALUE or MIN_VALUE, then it might cause an integer overflow.\n\n But since the method returns an int, we should consider what happens in case of overflow?\n In Java, if the result is too big for an int, it will wrap around (two's complement).\n However, without specific requirements, let's just test with typical cases and maybe one that causes overflow?\n\n Since JUnit5 does not have built-in assertions for integer overflow, we can check by comparing expected values.\n\n Let's break down:\n\n Normal positive: 2 * 3 = 6\n Negative: -1 * -4 = 4, -1 * 4 = -4\n Zero: 0 * anything is 0.\n\n Overflow cases (if a and b are both very large positive numbers):\n   Integer.MAX_VALUE * Integer.MAX_VALUE -> This will overflow because MAX_VALUE is about 2e9 and squaring gives ~4e18 which is too big for int.\n   Similarly, Integer.MIN_VALUE * -1 might be the smallest negative but not necessarily an issue.\n\n However, note that the problem says to create Junit5 tests. We'll write tests accordingly.\n\n Steps:\n 1. Create a test class named CalculatorTest (or similar).\n 2. Write test methods for each scenario.\n\n Let's consider writing:\n\n - multiplyPositiveNumbers\n - multiplyNegativeNumbers\n - multiplyByZero\n\n And then an overflow test? But note: the problem doesn't specify, but let's assume we want to cover it because it's a common pitfall.\n\n We can write:\n   @Test\n   void positiveMultiply() { ... }\n\n   @Test\n   void negativeMultiply() { ... }\n\n   @Test\n   void multiplyByZero() { ... }\n\n   @Test\n   @DisplayName(\"Should handle integer overflow\")\n   void testOverflow() {\n        // Test case that causes overflow, but note: the method returns int and it will wrap around.\n        // We can check by comparing with expected value after wrapping.\n\n        // Example from JLS: Integer.MAX_VALUE * 1 should be MAX_VALUE? Actually no, because MAX_VALUE is so big even multiplying by a small positive might cause overflow if we use two large numbers.\n\n        // Let's test two very large positive numbers that exceed the int range when multiplied.\n        // We can compute expected value and then check against actual. But note: due to wrapping, it will be different.\n\n        // Alternatively, we can rely on Java behavior because JUnit doesn't have a way to catch exceptions for integer overflow in primitive types (unless we use BigInteger or long).\n\n        // Since the method returns int and the inputs are int, we don't know if an exception should be thrown. In fact, no exception is thrown.\n\n        // We can test: 1073741825 * 1073741825 -> This might cause overflow but let's compute:\n\n        // Integer.MAX_VALUE = 2147483647\n        // So, we need two numbers a and b such that a*b > Integer.MAX_VALUE? But note: if both are positive and their product is beyond MAX_VALUE, then it will wrap.\n\n        // However, the problem does not specify what to do in overflow. We might just want to check that it returns something (maybe as expected by wrapping) but without any requirement.\n\n        // Let's compute an example:\n\n        int a = Integer.MAX_VALUE;\n        int b = 2; // This will cause overflow because MAX_VALUE * 2 is about 4.3e9, which is more than INT_MAX.\n        int result = Calculator.multiply(a, b);\n        // Expected: wrapping around to negative number? Because the product of two positive numbers that exceed INT_MAX becomes a very large positive number, then when stored in an int it wraps.\n\n        // We can compute:\n        long expectedLongValue = (long)a * b;\n        if (expectedLongValue > Integer.MAX_VALUE) {\n            result should be equal to the wrapped value? But we don't know what that is without computation.\n\n        Alternatively, we can check by comparing with a known overflowed value, but note: the behavior is defined and predictable because of two's complement.\n\n        However, let me compute:\n          2147483647 * 2 = 4294967294\n          But int max is 2147483647, so this will overflow. The correct way to think about it: \n          In two's complement, the result of an integer multiplication that overflows will be truncated by taking only the lower 32 bits.\n\n        We can compute in hex or use a known fact? Alternatively, we can just let the test pass and check against the expected wrapped value.\n\n        Since JUnit5 does not have assertions for wrapping, we might rely on the fact that it returns an int and then compare with what we expect by wrapping.\n\n        But note: without knowing the exact overflow behavior in terms of a specific number, we can't write a direct comparison test.\n\n        Another idea: use reflection to catch exceptions? Actually, no exception is thrown for integer overflow. So maybe not.\n\n        We might skip the overflow test because it's implementation defined and unless required by specification, it should be handled as wrapping.\n\n        But let me think of an alternative: we can check if the result is what we expect from a long multiplication (if that value fits in int then no problem, else it's wrapped). However, without knowing the expected wrapped value, we cannot do direct comparison.\n\n        We could write:\n\n          @Test\n          void testOverflow() {\n              // This will cause overflow because 2147483647 * 2 is too big for int.\n              int a = Integer.MAX_VALUE;\n              int b = 2;\n\n              // The expected result of wrapping: \n              long product = (long)a * b;   // This avoids integer overflow and gives the correct value as if it were stored in long, then we can check how it wraps.\n\n              // But without knowing the exact wrapped value, we cannot assert. However, note that the behavior is defined by Java to wrap around using two's complement arithmetic.\n\n              // We could compare with a known example: \n              int result = Calculator.multiply(a, b);\n\n              // Let me compute what should be the expected int value for 2147483647 * 2.\n              // The product is 4294967294. Now, to represent this in a 32-bit signed integer:\n              // We can convert it back: \n              long wrappedProduct = (long)result;   // This doesn't help because result is the same as what we computed by wrapping? Not exactly.\n\n              Actually, let me do:\n\n                  product = Integer.MAX_VALUE * 2;\n                  Then in int, it will be stored modulo 2^32. So:\n\n                  We can compute: \n                      expectedResult = (int)((long)Integer.MAX_VALUE * 2);\n                  But note: casting long to int truncates the value.\n\n              However, we cannot know without computation what that truncated value is? Actually, we can compute it by doing:\n\n                  product = Integer.MAX_VALUE * 2;   // This overflows and gives -2 (if I recall correctly) because of two's complement wrapping?\n\n              Let me check: \n                  In two's complement, the maximum positive integer is 0x7FFFFFFF (2147483647).\n                  Adding one more would be 0x80000000 which is -2^31.\n\n              So for Integer.MAX_VALUE * 2:\n\n                  MAX_VALUE = 0x7FFFFFFF\n                  product in long: 0x7FFFFFFF * 0x7FFFFFFF (but wait, we are doing with a=MAX_VALUE and b=2)\n\n                  Let me compute: \n                      result = a * b;\n                  Without overflow handling, the calculation would be:\n\n                      We have two numbers:\n                          a: 0111...1111 (32 bits)\n                          b: 0000...0010\n\n                  The product is beyond what can be represented in signed 32-bit. So it wraps.\n\n              How to compute the wrapped value?\n\n                  We can do:\n                      long exactProduct = (long)a * b;\n                      Then, if we want to know how it would wrap:\n\n                      Since int multiplication uses two's complement arithmetic and truncates to 32 bits, we can take the lower 32 bits of the exact product.\n\n                  But note: in Java, integer overflow wraps around. So for example:\n\n                      Integer.MAX_VALUE * 2 = -2147483650   (I think that's the case)\n\n              Let me verify with a simple calculation:\n\n                  MAX_VALUE is 2^31-1.\n                  Then (2^31-1)*2 = 2^32 + (-2) -> because:\n                      2^31 * 2 = 2^32, and then subtracting the extra? Actually no.\n\n                  In two's complement, when you add an integer that overflows, it wraps around. But multiplication is more complex.\n\n              Alternatively, we can use:\n\n                  int result = Calculator.multiply(a, b);\n                  long expectedResultLongValue = (long)result;\n\n                  And then check if the absolute value of the product is huge? Not really.\n\n              Since without a specific requirement, maybe we don't need to test overflow. But let's assume that we want to ensure it returns an int even in case of overflow.\n\n              We can write:\n\n                  @Test\n                  void testOverflow() {\n                      int result = Calculator.multiply(Integer.MAX_VALUE, 2);\n                      // Expected wrapped value: -2147483650 (if I remember correctly)\n\n                      assertEquals(-2147400000, result);   // This is an approximate check because the exact wrapped value depends on the system.\n\n                  But note: the exact wrapping behavior for integer overflow in multiplication is defined by Java and it's two's complement. The example:\n\n                      Integer.MAX_VALUE * 2 = -2147483650\n\n                  Let me compute that with a calculator:\n\n                      2^31-1 = 2147483647\n                      Then (long)Integer.MAX_VALUE * 2 is 4294967294.\n\n                  Now, to convert this long value to int by truncating the higher bits? Actually, when we do:\n\n                      int a = Integer.MAX_VALUE;\n                      int b = 2;\n\n                  and then multiply in integer arithmetic, it does not throw an exception. Instead, it returns the truncated result (the lower 32 bits of the exact product).\n\n                  The long value 4294967294 has more than 32 bits? Let me check:\n\n                      Long.numberOfLeadingZeros(4294967294L) ... but actually, it's a positive number and its binary representation is longer.\n\n                  We can compute the lower 32 bits of 4294967294 by taking modulo (1<<32). But note: in two's complement, negative numbers are represented differently.\n\n                  Alternatively, we can think about:\n\n                      The product is too big for int. So it wraps around to a positive number? Actually no, because the multiplication of two positive ints that overflow will become a negative int?\n\n                  Let me compute with actual Java code:\n\n                      System.out.println(Integer.MAX_VALUE * 2);   // This prints -2\n\n              Wait, let me run it in my mind:\n\n                  Integer.MAX_VALUE is 0x7FFFFFFF (32-bit: all ones except the last bit which is one for positive).\n                  Multiply by 2: \n                    In binary, shifting left by one and then setting the sign bit appropriately? But note that integer multiplication does not shift.\n\n              Actually, let me compute:\n\n                  MAX_VALUE = 0x7FFFFFFF (hex) -> in decimal it's 2147483647.\n                  Then, multiplying by two: \n                    We do an exact calculation until we have more than 32 bits? No, because the hardware doesn't know about Java. It does:\n\n                    result = product of a and b (as if stored in infinite precision) but then truncated to int.\n\n              How is truncation done?\n\n                  The product as a long would be 4294967294.\n                  Then, when converting back to int, the higher bits are discarded. So:\n\n                  result = (int)(product)\n\n                  But note: in two's complement, the sign bit is the highest bit.\n\n                  Let me convert 4294967294L to an integer by truncating:\n\n                    The lower 32 bits of 4294967294 are:\n\n                      We can break it down:\n\n                        4294967294 in binary (using long representation) is: \n                          ...0111...1111\n\n                  Actually, let me convert the hex value of MAX_VALUE * 2 to int.\n\n                  Alternatively, we can use:\n\n                      result = Integer.MAX_VALUE * 2;\n\n                  In Java, this expression will be evaluated as an integer multiplication and then truncated. The expected result is -2 because:\n\n                    We have: \n                      (long)Integer.MAX_VALUE * 2 -> 4294967294\n                    Then, converting to int by truncating the higher bits? Actually, no exception in Java for this.\n\n                  Wait, let me check with code:\n\n                      public static void main(String[] args) {\n                          System.out.println(Integer.MAX_VALUE * 2);\n                      }\n\n                  I just ran it and got -2. So the wrapped value is indeed -2 for MAX_VALUE*2.\n\n              Now, to verify: \n\n                  Let a = Integer.MAX_VALUE (which is 2147483647)\n                  b = 2\n\n                  Then result should be:\n\n                      We can compute by hand the product in two's complement:\n\n                  But note: we are not required to test overflow behavior unless specified. However, let's write a test that checks this.\n\n              Alternatively, we might skip and just rely on normal arithmetic tests because the problem does not specify any requirement for overflow.\n\n  Given the above, I will write:\n\n      - Test positive numbers\n      - Test negative numbers (both same sign and different signs)\n      - Test zero\n\n  And if required by specification to handle overflow in a particular way, then we can add more. But without that, maybe not.\n\n Let's code accordingly.\n</think>\nTo test the `multiply` method in the `Calculator` class using JUnit5, follow these steps:\n\n1. **Add JUnit5 Dependency**: Ensure your project includes JUnit5 (Jupiter API).\n2. **Create Test Class**: Name it `CalculatorTest`.\n3. **Write Test Methods**: Cover positive numbers, negative numbers, zero, and potential integer overflow cases.\n\nHere's the test code:\n\n```java\nimport org.junit.jupiter.api.Test;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    void multiplyPositiveNumbers() {\n        int a = 10;\n        int b = 5;\n        assertEquals(50, Calculator.multiply(a, b));\n    }\n\n    @Test\n    void multiplyNegativeNumbers() {\n        int a = -3;\n        int b = -7;\n        assertEquals(21, Calculator.multiply(a, b));\n        \n        int c = -4;\n        int d = 8;\n        assertEquals(-32, Calculator.multiply(c, d));\n    }\n\n    @Test\n    void multiplyByZero() {\n        int a = 99;\n        int b = 0;\n        assertEquals(0, Calculator.multiply(a, b));\n\n        IntStream.rangeClosed(-100, 100).forEach(x ->\n            assertEquals(0, Calculator.multiply(x, Integer.MAX_VALUE))\n        );\n    }\n\n    @Test\n    void testIntegerOverflow() {\n        // Example where result exceeds MAX_VALUE (wraps around)\n        int a = Integer.MAX_VALUE;\n        int b = -2; // Ensures the product is negative and wraps correctly\n\n        long expectedProductSigned = (long) a * b; // Avoids integer overflow\n        assertEquals((int) expectedProductSigned, Calculator.multiply(a, b));\n    }\n}\n```\n\n**Explanation:**\n\n- **multiplyPositiveNumbers**: Tests positive inputs producing a positive result.\n- **multiplyNegativeNumbers**: Verifies both negative-negative and negative-positive cases (returns positive or negative).\n- **multiplyByZero**: Checks multiplication by zero with any number results in zero. Uses `IntStream` to efficiently test all integer values from -100 to 100 multiplied by the maximum int value.\n- **testIntegerOverflow**: Tests overflow where a very large positive result wraps around due to Java's two's complement arithmetic. Here, multiplying MAX_VALUE by -2 results in a negative number that correctly wraps (e.g., `2147483647 * (-2) = -4294967294` which fits within int range).\n\nThis test suite ensures the method behaves as expected under various conditions, including handling integer overflow gracefully. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Error with reuqest [[OllamaGenerateRequest(model=phi4, prompt=Create Junit5 tests for function public class Calculator{public static int add(inta,intb){\n        return a + b;\n    \n}\n}\n, suffix=null, images=null, think=null, format=null, options=null, system=null, template=null, stream=false, raw=null, keep_alive=null)]]: Unexpected code Response{protocol=http/1.1, code=500, message=Internal Server Error, url=http://localhost:18502/api/generate} :: {\"error\":\"model requires more system memory (9.7 GiB) than is available (8.3 GiB)\"}"
      },
      "llmModel": "cache-Ollama-phi4",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:09:52.214049600Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-llava",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:43:41.054450700Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  ```\\npackage com.example;\\n\\nimport org.junit.jupiter.api.*;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\npublic class CalculatorTest {\\n\\n    @Test\\n    public void testSubtract() {\\n        int a = 5;\\n        int b = 3;\\n        int expectedResult = 2;\\n        int result = Calculator.subtract(a, b);\\n        assertEquals(expectedResult, result);\\n    }\\n\\n    @Test\\n    public void testSubtractWhenAIsGreaterThanB() {\\n        int a = 7;\\n        int b = 5;\\n        int expectedResult = 2;\\n        int result = Calculator.subtract(a, b);\\n        assertEquals(expectedResult, result);\\n    }\\n\\n    @Test\\n    public void testSubtractWhenAIsLessThanB() {\\n        int a = 3;\\n        int b = 7;\\n        int expectedResult = -4;\\n        int result = Calculator.subtract(a, b);\\n        assertEquals(expectedResult, result);\\n    }\\n\\n    @Test\\n    public void testSubtractWhenAIsEqualToB() {\\n        int a = 3;\\n        int b = 3;\\n        int expectedResult = 0;\\n        int result = Calculator.subtract(a, b);\\n        assertEquals(expectedResult, result);\\n    }\\n}\\n```  \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  Here is an example of JUnit5 tests for the `divide` function in the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.*;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\npublic class CalculatorTest {\\n    @Nested\\n    @DisplayName(\\\"Tests for Calculator\\\")\\n    public class CalculatorTests {\\n        @Test\\n        void testDivide() {\\n            // Test with valid inputs\\n            double result = Calculator.divide(4.0, 2.0);\\n            assertEquals(2.0, result);\\n            \\n            result = Calculator.divide(-6.0, -3.0);\\n            assertEquals(2.0, result);\\n            \\n            // Test with zero divisor\\n            assertThrows(ArithmeticException.class, () -> Calculator.divide(5.0, 0));\\n            \\n            // Test with negative divisor\\n            assertThrows(ArithmeticException.class, () -> Calculator.divide(-2.0, -1.0));\\n        }\\n    }\\n}\\n```\\nThis test class contains a nested test class `CalculatorTests` which has a single test method `testDivide`. This test method uses the `assertEquals` and `assertThrows` methods to check that the `divide` function returns the expected result for valid inputs, and throws an exception when the divisor is zero or negative.\\n\\nYou may also want to test other features of your Calculator class such as addition, subtraction and multiplication by creating different test cases for each feature.  \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='llama3.2', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-llama3.2",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:05:42.153207900Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here are some example test cases for the `Calculator` class using Python's built-in `unittest` module:\n\n```python\nimport unittest\nfrom calculator import Calculator  # Import the Calculator class from your file\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = Calculator()  # Create an instance of the Calculator class for each test\n\n    def test_add_positive_numbers(self):\n        result = self.calculator.add(2, 3)\n        self.assertEqual(result, 5)\n\n    def test_add_negative_numbers(self):\n        result = self.calculator.add(-2, -3)\n        self.assertEqual(result, -5)\n\n    def test_add_mixed_numbers(self):\n        result = self.calculator.add(-2, 3)\n        self.assertEqual(result, 1)\n\n    def test_add_zero(self):\n        result = self.calculator.add(0, 5)\n        self.assertEqual(result, 5)\n\n    def test_add_non_numeric_values(self):\n        with self.assertRaises(TypeError):\n            self.calculator.add('a', 2)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn these tests:\n\n- `test_add_positive_numbers`: Verifies that the function adds two positive numbers correctly.\n- `test_add_negative_numbers`: Checks if the function handles negative inputs correctly.\n- `test_add_mixed_numbers`: Tests the behavior when one input is negative and the other is positive.\n- `test_add_zero`: Confirms the result when both inputs are zero or when one of them is zero.\n- `test_add_non_numeric_values`: Ensures that a TypeError is raised when non-numeric values are passed to the function.\n\nNote: Make sure to replace `'calculator'` with the actual path to your file where `Calculator` class is defined. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can create unit tests for the `Calculator` class using Python's built-in `unittest` module:\n\n```python\nimport unittest\nfrom calculator import Calculator  # Assuming your Calculator class is in a file called 'calculator.py'\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = Calculator()\n\n    def test_subtract_positive_numbers(self):\n        result = self.calculator.subtract(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_subtract_negative_numbers(self):\n        result = self.calculator.subtract(-10, -5)\n        self.assertEqual(result, -5)\n\n    def test_subtract_mixed_numbers(self):\n        result = self.calculator.subtract(10, -5)\n        self.assertEqual(result, 15)\n\n    def test_subtract_zero(self):\n        with self.assertRaises(ZeroDivisionError):  # Assuming subtract function raises ZeroDivisionError when b is zero\n            self.calculator.subtract(10, 0)\n\n    def test_subtract_non_numeric_values(self):\n        with self.assertRaises(TypeError):  # Assuming subtract function raises TypeError when inputs are not numbers\n            self.calculator.subtract('a', 5)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this example:\n\n*   We create a `TestCalculator` class that inherits from `unittest.TestCase`.\n*   The `setUp` method is used to initialize the `calculator` object before each test.\n*   Each test method (`test_subtract_positive_numbers`, etc.) tests a specific scenario with the `subtract` function.\n*   We use assertions (e.g., `self.assertEqual(result, 5)`) to verify that the expected result matches the actual output.\n\nNote that I've added some additional test cases for edge scenarios:\n\n*   `test_subtract_zero`: Tests what happens when one of the inputs is zero.\n*   `test_subtract_non_numeric_values`: Tests what happens when one or both inputs are not numbers. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can create unit tests for the `Calculator` class using Python's built-in `unittest` module:\n\n```python\nimport unittest\nfrom calculator import Calculator  # Import the Calculator class\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_multiply(self):\n        \"\"\"Test that multiply returns the correct result\"\"\"\n        self.assertEqual(self.calc.multiply(2, 3), 6)\n\n    def test_multiply_with_negative_numbers(self):\n        \"\"\"Test that multiply works with negative numbers\"\"\"\n        self.assertEqual(self.calc.multiply(-2, -3), 6)\n\n    def test_multiply_with_zero(self):\n        \"\"\"Test that multiply returns zero when one of the inputs is zero\"\"\"\n        self.assertEqual(self.calc.multiply(0, 3), 0)\n        self.assertEqual(self.calc.multiply(2, 0), 0)\n\n    def test_multiply_with_floats(self):\n        \"\"\"Test that multiply works with floats\"\"\"\n        self.assertAlmostEqual(self.calc.multiply(2.5, 3), 7.5)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this example:\n\n1. We import the `Calculator` class and create a test case using `unittest.TestCase`.\n2. The `setUp` method is called before each test to initialize the calculator object.\n3. Each test method (e.g., `test_multiply`) contains a test assertion that checks the behavior of the `multiply` method under different scenarios.\n\nNote: We're using `assertAlmostEqual` when testing with floats, as floating-point arithmetic can sometimes introduce small rounding errors.\n\nTo run these tests, save this code to a file (e.g., `test_calculator.py`) and execute it using Python:\n\n```bash\npython test_calculator.py\n```\n\nIf all the tests pass, you should see an output indicating that all tests were successful. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write unit tests for the `Calculator` class using Python's built-in `unittest` module:\n\n```python\nimport unittest\nfrom calculator import Calculator  # Import the Calculator class\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calc = Calculator()\n\n    # Test that division by zero raises an exception\n    def test_divide_by_zero(self):\n        with self.assertRaises(ValueError):\n            self.calc.divide(10, 0)\n\n    # Test successful division\n    def test_successful_division(self):\n        result = self.calc.divide(10, 2)\n        self.assertEqual(result, 5)\n\n    # Test that invalid data types are handled correctly\n    def test_invalid_data_types(self):\n        with self.assertRaises(TypeError):\n            self.calc.divide(\"a\", 2)\n        with self.assertRaises(TypeError):\n            self.calc.divide(10, \"b\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nIn this code:\n\n- We define a `TestCalculator` class that inherits from `unittest.TestCase`.\n- In the `setUp` method, we create an instance of the `Calculator` class.\n- The first test checks if division by zero raises the expected exception.\n- The second test checks if successful division works as expected.\n- The third test checks if division with invalid data types (strings instead of numbers) raises a TypeError.\n\nTo make this code work, you need to modify your `Calculator` class to handle the case where either input is not an integer. Here's how you could do it:\n\n```python\nclass Calculator:\n    def divide(self,a,b):\n       if(b==0 or not isinstance(a,int) or not isinstance(b,int)):\n           raise \"Invalid Input\"\n       return a/b\n```\n\nThis version of `Calculator` class will also fail when one of the inputs is not an integer. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='moondream', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-moondream",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:42:38.148909800Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nimport unittest\\nfrom calculator import Calculator\\nclass TestCalculatorMethods(unittest.TestCase):\\n  def setUp(self):\\n   pass\\n  def tearDown(self):\\n   pass\\n  def test_addition(self):\\n   calc = Calculator()\\n   self.assertEqual(calc.add(2,3),5) \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nimport unittest\\nfrom calculator import Calculator\\nclass TestCalculatorMethods(unittest.TestCase):\\n  def test_calculator(self):\\n    calc = Calculator()\\n    self.assertEqual(calc.add(2,3), 5)\\n    self.assertEqual(calc.subtract(5, 2), 3) \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nimport unittest\\nfrom calculator import Calculator\\nclass TestCalculatorMethods(unittest.TestCase):\\n  def setUp(self):\\n   pass\\n  def test_calculate(self):\\n   calc = Calculator()\\n   self.assertEqual(calc.multiply(2,3), 6) \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nimport unittest\\nfrom calculator import Calculator\\nclass TestCalculatorMethods(unittest.TestCase):\\n    def setUp(self):\\n        pass\\n  \\n    def test_calc(self):\\n        calc = Calculator()\\n        self.assertEqual(calc.add(2,3), 5)\\n \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-llama3.2:1b",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:05:56.488289700Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-gemma3:1b",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T08:59:33.479396600Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='granite3.3', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-granite3.3",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T14:21:09.253033100Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n 1. Import the necessary modules:\n```python\nimport unittest\nfrom your_module import Calculator  # replace 'your_module' with the actual module name\n```\n\n2. Create a test case class that inherits from `unittest.TestCase`:\n```python\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = Calculator()\n```\n\n3. Write test methods for the `add` function:\n```python\n    def test_add_positive_numbers(self):\n        self.assertEqual(self.calculator.add(1, 2), 3)\n\n    def test_add_negative_numbers(self):\n        self.assertEqual(self.calculator.add(-1, -2), -3)\n\n    def test_add_mixed_numbers(self):\n        self.assertEqual(self.calculator.add(-1, 1), 0)\n```\n\n4. Run the tests:\n```python\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis will create a simple unit test for the `add` function in the `Calculator` class. You can add more test cases as needed. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n 1. Import the necessary modules:\n```python\nimport unittest\nfrom your_module import Calculator  # replace 'your_module' with the actual module name\n```\n\n2. Create a test case class that inherits from `unittest.TestCase`:\n```python\nclass TestCalculator(unittest.TestCase):\n```\n\n3. Write test methods for the `subtract` function:\n```python\n    def test_subtract_positive_numbers(self):\n        calculator = Calculator()\n        self.assertEqual(calculator.subtract(10, 5), 5)\n\n    def test_subtract_negative_numbers(self):\n        calculator = Calculator()\n        self.assertEqual(calculator.subtract(-5, -10), 5)\n\n    def test_subtract_zero(self):\n        calculator = Calculator()\n        self.assertEqual(calculator.subtract(0, 5), -5)\n\n    def test_subtract_mixed_numbers(self):\n        calculator = Calculator()\n        self.assertEqual(calculator.subtract(-5, 3), -8)\n```\n\n4. Run the tests:\n```python\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis will create a set of unit tests for the `subtract` function in the `Calculator` class. Make sure to replace `'your_module'` with the actual module name where the `Calculator` class is defined. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n 1. Import the necessary modules:\n```python\nimport unittest\nfrom calculator import Calculator\n```\n\n2. Create a test case class that inherits from `unittest.TestCase`:\n```python\nclass TestCalculator(unittest.TestCase):\n```\n\n3. Write test methods for the `multiply` function. Each method should start with the prefix `test_`:\n```python\n    def test_multiply_positive_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(3, 4), 12)\n\n    def test_multiply_negative_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(-3, -4), 12)\n\n    def test_multiply_positive_and_negative_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(-3, 4), -12)\n\n    def test_multiply_zero(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(0, 15), 0)\n```\n\n4. Run the tests using the `unittest` module:\n```python\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThe complete test suite would look like this:\n\n```python\nimport unittest\nfrom calculator import Calculator\n\nclass TestCalculator(unittest.TestCase):\n\n    def test_multiply_positive_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(3, 4), 12)\n\n    def test_multiply_negative_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(-3, -4), 12)\n\n    def test_multiply_positive_and_negative_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(-3, 4), -12)\n\n    def test_multiply_zero(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(0, 15), 0)\n\nif __name__ == '__main__':\n    unittest.main()\n``` \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n 1. Import the necessary libraries:\n```python\nimport unittest\nfrom calculator import Calculator\n```\n\n2. Create a test case class that inherits from `unittest.TestCase`:\n```python\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = Calculator()\n```\n\n3. Write test methods for the `divide` function:\n```python\n    def test_divide_positive_numbers(self):\n        result = self.calculator.divide(10, 2)\n        self.assertEqual(result, 5)\n\n    def test_divide_negative_numbers(self):\n        result = self.calculator.divide(-10, -2)\n        self.assertEqual(result, 5)\n\n    def test_divide_zero(self):\n        with self.assertRaises(Exception) as context:\n            self.calculator.divide(10, 0)\n        self.assertTrue(\"Cannot divide by zero\" in str(context.exception))\n```\n\n4. Run the tests:\n```python\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThe complete code would look like this:\n\n```python\nimport unittest\nfrom calculator import Calculator\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = Calculator()\n\n    def test_divide_positive_numbers(self):\n        result = self.calculator.divide(10, 2)\n        self.assertEqual(result, 5)\n\n    def test_divide_negative_numbers(self):\n        result = self.calculator.divide(-10, -2)\n        self.assertEqual(result, 5)\n\n    def test_divide_zero(self):\n        with self.assertRaises(Exception) as context:\n            self.calculator.divide(10, 0)\n        self.assertTrue(\"Cannot divide by zero\" in str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()\n``` \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Error with reuqest [[OllamaGenerateRequest(model=deepseek-r1, prompt=Create unittest tests for function class Calculator:\n    def divide(self,a,b):\n       if(b==0):\n           raise \"Cannot divide by zero\"\n       return a/b\n\n\n, suffix=null, images=null, think=null, format=null, options=null, system=null, template=null, stream=false, raw=null, keep_alive=null)]]: timeout"
      },
      "llmModel": "cache-Ollama-deepseek-r1",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T12:29:26.005313700Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n <think>\nWe are going to test the add method of the Calculator class.\n Since the function is very simple, we can write several test cases:\n\n 1. Test with two positive integers.\n 2. Test with two negative integers.\n 3. Test with one positive and one negative integer (positive + negative).\n 4. Test with zero inputs.\n\n However, note that the provided code does not show a class structure. \n Let's assume we have a Calculator class with an `add` method that takes two arguments, but if only one is provided, it can handle as well?\n But the function signature given is: def add(self,a,b): which suggests two required arguments.\n\n Since the problem says to create tests for this function and does not specify a class structure beyond what's shown, \n I'll write tests assuming that we are testing a method of an object. However, note that if `add` is intended to be called as part of an instance,\n then we should test with an instance.\n\n But the problem doesn't show how the Calculator class is defined. Let me clarify:\n\n We have two possibilities:\n   - The function might be in a class and require instantiation.\n   - Or it could be a static method or a function that takes two arguments directly.\n\n Since the code says `def add(self,a,b):`, I assume we are to test an instance method of a Calculator class.\n\n However, if we don't have the rest of the class, then perhaps we can just mock an instance and call its method?\n\n But let's stick to the requirement: create unittest tests for the given function/class structure.\n\n Since there is no context about other methods or state, I will assume that the `add` method does not rely on any internal state (other than the two arguments).\n\n We'll write a test class for Calculator and test the add method with several cases.\n</think>\nTo solve this problem, we need to create unit tests for the `add` method of a `Calculator` class. The goal is to ensure that the addition operation works correctly under various conditions, including positive numbers, negative numbers, zeros, floats, string inputs (if applicable), and edge cases like maximum values.\n\n### Approach\nThe approach involves testing different scenarios where the `add` method might be used:\n1. **Positive Numbers**: Test adding two positive integers.\n2. **Negative Numbers**: Test adding two negative integers or a mix of positive and negative numbers.\n3. **Zeros**: Test adding zero to any number, which should not change the result.\n4. **Floats**: Test adding decimal numbers.\n5. **Edge Cases**: Test with very large numbers that might cause overflow (though in Python, this is less common due to arbitrary precision integers).\n6. **String Inputs**: Although `a + b` for strings concatenates them, we should test if the method handles unexpected string inputs appropriately.\n\n### Solution Code\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n    def test_add_two_positive_numbers(self):\n        # Create an instance of Calculator (assuming it's defined elsewhere)\n        calc = Calculator()\n        self.assertEqual(calc.add(10, 5), 15)\n\n    def test_add_two_negative_numbers(self):\n        calc = Calculator()\n        result = calc.add(-3, -7)\n        self.assertEqual(result, -10)\n\n    def test_add_zero_and_positive_number(self):\n        calc = Calculator()\n        result = calc.add(42, 0)\n        self.assertEqual(result, 42)\n\n    def test_add_zero_and_negative_number(self):\n        calc = Calculator()\n        result = calc.add(-5, 0)\n        self.assertEqual(result, -5)\n\n    def test_add_two_zeros(self):\n        calc = Calculator()\n        result = calc.add(0, 0)\n        self.assertEqual(result, 0)\n\n    def test_add_floats(self):\n        calc = Calculator()\n        result = calc.add(1.5, 2.3)\n        self.assertAlmostEqual(result, 3.8)  # Using approximation for floats\n\n    def test_add_large_numbers(self):\n        calc = Calculator()\n        large_num = 10**100\n        result = calc.add(large_num, large_num)\n        expected = 2 * large_num\n        self.assertEqual(result, expected)\n\n    def test_add_strings(self):\n        # If the method is intended to handle only numbers, this might be an error case or exception.\n        # But if we want to check for handling string inputs (if allowed), then:\n        calc = Calculator()\n        with self.assertRaises(TypeError) as context:\n            calc.add(\"10\", \"5\")\n```\n\n### Explanation\n- **Positive Numbers**: Test cases like `test_add_two_positive_numbers` and `test_add_zero_and_positive_number` ensure that the method correctly adds positive integers.\n- **Negative Numbers**: Tests such as `test_add_two_negative_numbers` verify correct addition with negative numbers, including mixed signs (tested in other test cases).\n- **Zeros**: The case `test_add_two_zeros` checks adding two zeros and also implicitly tests adding zero to a number via the above methods.\n- **Floats**: Using `assertAlmostEqual` for floating-point arithmetic allows accounting for potential precision issues.\n- **Edge Cases**: Large numbers are tested with very large integers (e.g., \\(10^{100}\\)) to check if the method can handle big values without overflow or performance issues, though Python's integers handle arbitrarily large numbers so this is more about ensuring no errors occur.\n- **String Inputs**: This test checks that if non-numeric inputs are passed, an appropriate exception (TypeError) is raised. However, note that in some contexts, adding strings might be intended behavior, but given the method name `add`, it's assumed to perform numerical addition.\n\nThis approach ensures comprehensive coverage of the expected behaviors and potential edge cases for the `add` method. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n <think>\nWe are creating unit tests for the `subtract` method of a Calculator class.\n The function is simple, so we can test multiple cases including positive numbers, negative numbers, zero subtraction, and edge cases.\n\n Let's assume the calculator has an instance method called `subtract` that takes two arguments (self, a, b) and returns a-b.\n\n We'll use the unittest framework for this.\n</think>\nTo create unit tests for the `subtract` method of a Calculator class, we can use Python's `unittest` module. The goal is to verify that the subtraction operation works correctly under various scenarios, including normal cases, edge cases (like zero or negative results), and potential type issues.\n\n### Approach\nWe'll design test cases to cover:\n1. Basic positive number subtraction.\n2. Subtracting a larger number from a smaller one resulting in a negative result.\n3. Subtraction involving zero.\n4. Subtracting two zeros.\n5. Handling non-numeric inputs gracefully (raises TypeError).\n6. Ensuring the method does not modify input arguments.\n\n### Solution Code\n```python\nimport unittest\n\nclass Calculator:\n    def subtract(self, a, b):\n        return a - b\n\nclass TestCalculator(unittest.TestCase):\n    def test_subtract_positive_numbers(self):\n        # Normal case: both positive numbers\n        calc = Calculator()\n        result = calc.subtract(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_subtract_negative_result(self):\n        # Case when the result is negative\n        calc = Calculator()\n        result = calc.subtract(3, 8)\n        self.assertEqual(result, -5)\n\n    def test_subtract_zero(self):\n        # Subtract zero from a positive number\n        calc = Calculator()\n        result = calc.subtract(7, 0)\n        self.assertEqual(result, 7)\n\n    def test_subtract_same_number(self):\n        # Subtract two identical numbers resulting in zero\n        calc = Calculator()\n        result = calc.subtract(15, 15)\n        self.assertEqual(result, 0)\n\n    def test_subtract_negative_a_zero_b(self):\n        # Negative a and positive b (result is negative)\n        calc = Calculator()\n        result = calc.subtract(-3, 2)\n        self.assertEqual(result, -5)\n\n    def test_subtract_positive_a_negative_b(self):\n        # Positive number minus negative results in addition\n        calc = Calculator()\n        result = calc.subtract(4, -2)\n        self.assertEqual(result, 6)\n\n    def test_subtract_invalid_type(self):\n        # Test with non-numeric input (should raise TypeError)\n        calc = Calculator()\n        with self.assertRaises(TypeError):\n            calc.subtract(\"5\", 3)  # Or other invalid types\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n### Explanation\n1. **Normal Subtraction**: The first test checks subtracting two positive numbers to ensure the result is correct.\n2. **Negative Result**: Ensures that when a larger number is subtracted from a smaller one, the method returns a negative result correctly.\n3. **Zero Handling**: Tests subtracting zero from a number and ensures it does not change the value.\n4. **Same Numbers**: Subtracting two identical numbers should yield zero.\n5. **Mixed Signs - Negative Result**: Subtracts a positive number from a negative number to check if the operation works for resulting in a more negative number.\n6. **Mixed Signs - Addition Effect**: Positive minus negative results in addition, so this test checks that case.\n\nEach test ensures both inputs are numbers (integers or floats) and handles non-numeric types by raising an appropriate error. The tests cover different arithmetic cases to verify the correctness of the subtraction operation. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n <think>\nWe are going to write unit tests for the `multiply` method of a Calculator class.\n The function is very simple: it takes two arguments, multiplies them, and returns the product.\n\n We'll test for various cases including positive numbers, negative numbers, zero, decimals, edge cases (like large numbers), \n and also consider type checking if necessary. However, note that the problem does not specify any constraints on input types, so we assume integers or floats.\n\n Let's create a test class named TestCalculator with several test methods:\n\n 1. Test two positive integers.\n 2. Test two negative integers.\n 3. Test one positive and one negative integer.\n 4. Test zero multiplication (with various combinations: zero and non-zero, two zeros).\n 5. Test multiplying by zero (same as above but from different perspective? Actually same cases covered in point 1-4).\n 6. Test decimals.\n\n We'll use the unittest framework.\n\n However, note that the problem does not specify any constraints on input types beyond being numbers. \n But to be safe, we can also consider testing non-number inputs if necessary. Since the function doesn't check for type, \n it might fail but in a real scenario, you would want to handle exceptions or ensure proper types.\n\n We are only asked to test the multiply method, so let's focus on that.\n\n Let's assume the Calculator class has this method and we'll write tests accordingly.\n</think>\nTo create unit tests for the `multiply` method of the `Calculator` class, we can use Python's `unittest` framework. Below is a set of tests covering various scenarios including positive numbers, negative numbers, zero, large numbers, decimals, string inputs (if not handled), and edge cases.\n\n```python\nimport unittest\n\nclass Calculator:\n    def multiply(self, a, b):\n        return a * b\n\nclass TestMultiply(unittest.TestCase):\n\n    def test_positive_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(3, 4), 12)\n        self.assertEqual(calc.multiply(7, 9), 63)\n\n    def test_negative_numbers(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(-5, -8), 40)  # negative times negative is positive\n        self.assertEqual(calc.multiply(-3, 4), -12)\n        self.assertEqual(calc.multiply(3, -4), -12)\n\n    def test_zero_multiplication(self):\n        calc = Calculator()\n        self.assertEqual(calc.multiply(5, 0), 0)\n        self.assertEqual(calc.multiply(-7, 0), 0)\n        self.assertEqual(calc.multiply(0, 9), 0)\n        self.assertEqual(calc.multiply(0, -3), 0)\n\n    def test_large_numbers(self):\n        calc = Calculator()\n        a = 10**15\n        b = 2 * (10**15)\n        result = calc.multiply(a, b)\n        expected = 2e30\n        self.assertEqual(result, expected)  # This may fail if the language uses integer arithmetic\n\n    def test_decimals(self):\n        calc = Calculator()\n        self.assertAlmostEqual(calc.multiply(2.5, 4), 10.0)\n        self.assertAlmostEqual(calc.multiply(-1.1, -2.2), 2.42)\n\n    def test_string_input(self):\n        # Check if the function handles string inputs gracefully or not\n        calc = Calculator()\n        with self.assertRaises(TypeError):\n            calc.multiply(\"a\", 5)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n### Explanation:\n- **Test Positive Numbers**: Tests multiplication of two positive integers.\n- **Test Negative Numbers**: Checks scenarios where one or both numbers are negative to ensure correct sign handling and magnitude.\n- **Test Zero Multiplication**: Verifies the result is zero in all cases involving at least one zero.\n- **Test Large Numbers**: Ensures that multiplying very large numbers still works. The expected value uses floating-point notation, but note that Python integers can handle arbitrary size without overflow, so this test might be better for floats or adjusted to use big integers if needed.\n- **Test Decimals**: Uses `assertAlmostEqual` due to floating-point precision issues when dealing with decimals.\n- **Test String Input**: Checks that non-numeric inputs raise a TypeError.\n\nThese tests cover basic functionality and edge cases. If the method is expected to handle only numbers (like floats or ints), then string input might not be intended, but it's included for robustness. Adjustments can be made based on specific requirements if needed. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='llama3.2:1b', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-llama3.2:1b",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:09:41.822113100Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n To create unittest tests for the `Calculator` class, you can use the following code:\n\n```python\nimport unittest\nfrom calculator import Calculator  # Import the Calculator class from the calculator module\n\nclass TestCalculator(unittest.TestCase):\n\n    def test_add_two_positive_numbers(self):\n        calculator = Calculator()\n        result = calculator.add(5, 3)\n        self.assertEqual(result, 8)\n\n    def test_add_two_negative_numbers(self):\n        calculator = Calculator()\n        result = calculator.add(-2, -4)\n        self.assertEqual(result, -6)\n\n    def test_add_one_positive_and_one_negative_number(self):\n        calculator = Calculator()\n        result = calculator.add(5, -2)\n        self.assertEqual(result, 3)\n\n    def test_add_multiple_positive_numbers(self):\n        calculator = Calculator()\n        result = calculator.add(10, 20, 30)\n        self.assertEqual(result, 60)\n\n    def test_add_zero_to_non_positive_number(self):\n        calculator = Calculator()\n        result = calculator.add(5, 0)\n        self.assertEqual(result, 5)\n\n    def test_add_negative_number_to_positive_number(self):\n        calculator = Calculator()\n        result = calculator.add(-2, 5)\n        self.assertEqual(result, 3)\n\n    def test_add_zero_to_zero(self):\n        calculator = Calculator()\n        result = calculator.add(0, 0)\n        self.assertEqual(result, 0)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this code:\n\n- We define a `TestCalculator` class that inherits from `unittest.TestCase`.\n- Inside the class, we create test methods for each of the assertions mentioned in the docstring.\n- Each test method creates an instance of the `Calculator` class and calls its `add` method with different inputs to verify the expected output.\n- The `assertEqual` method is used to check if the actual output matches the expected output.\n\nNote: These tests cover a range of common scenarios for the `add` method, including adding positive and negative numbers, zero to non-positive numbers, and multiple positive numbers. You can add more tests as needed to cover additional cases. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here's an example of how you can write unit tests for the `Calculator` class using Python's built-in `unittest` module:\n\n```python\nimport unittest\nfrom calculator import Calculator  # Import the Calculator class from your module\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = Calculator()  # Create a new instance of Calculator\n\n    def test_subtract(self):\n        # Test subtraction with positive numbers\n        result = self.calculator.subtract(5, 3)\n        self.assertEqual(result, 2)\n\n        # Test subtraction with negative numbers\n        result = self.calculator.subtract(-1, -5)\n        self.assertEqual(result, 6)\n\n    def test_subtract_mismatched_numbers(self):\n        # Test subtraction with different numbers of arguments (should raise an error)\n        with self.assertRaises(TypeError):\n            self.calculator.subtract(5, 'a')\n\n    def test_subtract_invalid_type(self):\n        # Test subtraction with non-numeric values\n        with self.assertRaises(TypeError):\n            self.calculator.subtract(5, 3.0)\n\n    def test_subtract_zero(self):\n        # Test subtraction with zero argument\n        result = self.calculator.subtract(0, 10)\n        self.assertEqual(result, 10)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn these tests, we cover the following scenarios:\n\n*   `test_subtract`: Verifies that the `subtract` method works correctly for subtracting two positive numbers and two negative numbers.\n*   `test_subtract_mismatched_numbers`: Checks that the `subtract` method raises a TypeError when given different numbers of arguments or non-numeric values.\n*   `test_subtract_invalid_type`: Tests that the `subtract` method raises a TypeError when given non-numeric values.\n*   `test_subtract_zero`: Verifies that the `subtract` method works correctly when given zero as an argument. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here are some example unittest tests for the `Calculator` class:\n\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calculator = Calculator()\n\n    def test_multiply(self):\n        # Test multiplying two numbers\n        result = self.calculator.multiply(2, 3)\n        self.assertEqual(result, 6)\n\n    def test_multiply_negative_numbers(self):\n        # Test multiplying two negative numbers\n        result = self.calculator.multiply(-2, -3)\n        self.assertEqual(result, 6)  # Expected result is positive\n\n    def test_multiply_zero(self):\n        # Test multiplying zero by any number\n        result = self.calculator.multiply(0, 5)\n        self.assertEqual(result, 0)\n\n    def test_multiply_non_numeric(self):\n        # Test multiplying two non-numeric values\n        with self.assertRaises(TypeError):\n            self.calculator.multiply('a', 3)\n\n    def test_multiply_int_division(self):\n        # Test dividing one integer by another (should raise ZeroDivisionError)\n        result = self.calculator.divide(10, 0)\n        self.assertEqual(result, None)  # or you could assertRaises with a custom error message\n\n    def test_multiply_too_many_args(self):\n        # Test multiplying three numbers\n        result = self.calculator.multiply(2, 3, 4)\n        self.assertEqual(result, 24)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this code:\n\n- We define a `TestCalculator` class that inherits from `unittest.TestCase`.\n- In the `setUp` method, we create an instance of `Calculator` before each test.\n- Each test method is prefixed with `test_<method_name>`, where `<method_name>` is the name of the method being tested (e.g., `multiply`, `divide`, etc.).\n- We use various assertions to verify that the method behaves correctly, such as checking return values or raising expected exceptions.\n\nNote: You may need to adjust the test names and expected outcomes based on your specific requirements and the behavior of your `Calculator` class. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here are some example unittest tests for the `Calculator` class:\n\n```python\nimport unittest\nfrom calculator import Calculator  # Replace with actual module name\n\nclass TestCalculator(unittest.TestCase):\n\n    def test_divide_positive(self):\n        calculator = Calculator()\n        result = calculator.divide(10, 2)\n        self.assertEqual(result, 5)\n\n    def test_divide_negative(self):\n        calculator = Calculator()\n        result = calculator.divide(-10, 2)\n        self.assertEqual(result, -5.0)  # Note: The return type is float\n\n    def test_divide_zero(self):\n        calculator = Calculator()\n        with self.assertRaises(\"Cannot divide by zero\"):\n            calculator.divide(10, 0)\n\n    def test_divide_negative_nonzero(self):\n        calculator = Calculator()\n        result = calculator.divide(-5, 2)\n        self.assertEqual(result, -2.5)  # Note: The return type is float\n\n    def test_division_by_zero_with_zero_divisor(self):\n        calculator = Calculator()\n        with self.assertRaises(\"Cannot divide by zero\"):\n            calculator.divide(0, 10)\n\n    def test_inverse_positive(self):\n        calculator = Calculator()\n        result = calculator.inverse(2)\n        self.assertEqual(result, 1/2)  # Note: The return type is float\n\n    def test_inverse_negative(self):\n        calculator = Calculator()\n        result = calculator.inverse(-2)\n        self.assertEqual(result, -1/-2)  # Note: The return type is float\n```\n\nThese tests cover a range of scenarios:\n\n- `test_divide_positive` and `test_divide_negative`: Test division operations with positive and negative inputs.\n- `test_divide_zero`, `test_divide_nonzero`, and `test_division_by_zero_with_zero_divisor`: Test division by zero cases, including the original error message and a more explicit `Cannot divide by zero` exception.\n- `test_inverse_positive` and `test_inverse_negative`: Test inverse operations with positive and negative inputs. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Report not found coverage.json"
      },
      "llmModel": "cache-Ollama-gemma3",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T08:59:48.667983100Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='phi4-mini', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-phi4-mini",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:20:43.785343500Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Sure! Here are some unit test cases using the `unittest` framework to validate your calculator's addition functionality.\n\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n\n    # Create an instance of the Calculator before each method is run.\n    def setUp(self):\n        self.calculator = Calculator()\n\n    # Check if adding two positive numbers returns their sum correctly.\n    def test_add_positive_numbers(self):\n        result = self.calculator.add(3, 5)\n        self.assertEqual(result, 8)\n\n    # Test that the addition of a negative and another number works properly\n    def test_add_negative_and_positive_number(self):\n        result = self.calculator.add(-2, 4)\n        self.assertEqual(result, 2)\n\n    # Verify adding two negatives gives correct positive sum.\n    def test_add_two_negatives(self):\n        result = self.calculator.add(-3, -5)\n        self.assertEqual(result, -8)\n\n    # Test the addition of a negative and zero\n    def test_add_negative_and_zero(self):\n        result = self.calculator.add(0, 7)\n        self.assertEqual(result, 7)\n\n    # Add two positive numbers to verify it works correctly.\n    def test_add_positive_numbers_nozeros(self):\n        result = self.calculator.add(10.5, -3.2)  # Example with floating point\n        expected_result = (10 + (-3)) /1   # Simplified representation for this example\n        self.assertAlmostEqual(result, float(expected_result), places=4)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test suite covers various scenarios to ensure that your `Calculator.add` function behaves as expected. Note the floating point addition in one of these tests; Python's division and rounding might behave differently from how you expect, hence we use `assertAlmostEqual`. You can adjust it according to what exact outcomes you're looking for with floats if needed.\n\nDon't forget:\n\n1. Your Calculator class should be defined somewhere above this code.\n2. Ensure all edge cases relevant in your context are tested! \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Sure! Below are the unittests created to test the `subtract` method of your `Calculator` class.\n\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_subtract_positive_numbers(self):\n        result = self.calc.subtract(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_subtract_negative_number_from_positive(self):\n        result = self.calc.subtract(10, -5)\n        self.assertEqual(result, 15)\n\n    def test_subtract_two_identical_positive_numbers(self):\n        result = self.calc.subtract(7, 7)\n        self.assertEqual(result, 0)\n\n    def test_subtract_negative_number_from_zero(self):\n        result = self.calc.subtract(-2, -5)   # Result should be negative\n        self.assertEqual(result, -3)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this code:\n1. The `Calculator` class is instantiated as part of the test setup.\n2. Various scenarios are tested to ensure that the subtraction method works correctly for different cases.\n\nYou may run these tests using a Python testing framework like `unittest`. Each function in your original calculator will be called and checked against expected results, ensuring comprehensive coverage across potential use-cases. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Sure! Here are some unittests you can create to test the `multiply` method of your `Calculator` class:\n\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n\n    # Initialize an instance of Calculator before tests if needed.\n    def setUp(self):\n        self.calculator = Calculator()\n\n    # Testing normal cases with positive numbers and zero.\n    def test_multiply_positive_numbers(self):\n        result = self.calculator.multiply(3, 4)\n        self.assertEqual(result, 12)\n\n    def test_multiply_negative_number_with_positive(self):\n        result = self.calculator.multiply(-2, 6)\n        self.assertEqual(result, -12)\n\n    # Testing case with negative numbers.\n    def test_multiply_two_negative_numbers(self):\n        result = self.calculator.multiply(-3, -4)\n        self.assertEqual(result, 12) \n\n    def test_multiply_zero_with_positive_number(self):\n        result = self.calculator.multiply(0, 5)\n        self.assertEqual(result, 0)\n\n    # Testing edge cases with large numbers.\n    def test_large_numbers_multiplied_together(self):\n        a = int('1' * 10000)   # Large positive number\n        b = int('-2')          # Negative multiplier\n        \n        result = self.calculator.multiply(a, b)\n        \n        expected_result = -a\n        self.assertEqual(result, expected_result)\n\n    def test_zero_multiplication(self):\n        a = 0\n        b = float('inf')\n        \n        with self.assertRaises(ValueError):  # Assuming multiply raises ValueError for infinity.\n            result = self.calculator.multiply(a, b)\n            \nif __name__ == '__main__':\n    unittest.main()\n```\n\nNotes:\n1. The `Calculator` class is assumed to be defined somewhere in your codebase as follows:\n\n```python\nclass Calculator():\n    def multiply(self,a,b):\n        return a*b\n```\n\n2. For testing edge cases like multiplying zero or handling very large numbers, you may need additional checks depending on the behavior of Python's integer and float types.\n\n3. Make sure to modify test conditions based upon any specific constraints (like if raising exceptions for certain inputs).\n\n4. Replace `with self.assertRaises(ValueError):` with appropriate exception handling as per your implementation in case it raises errors or behaves differently under special cases like infinity values that are not explicitly handled by the multiplication function.\n\n5. You may also need to adapt this code based on how you handle edge conditions and exceptions specifically within Python's context (e.g., using `float('inf')` vs other representations). \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Sure! Here are some `unittest` test cases to validate the behavior of your `Calculator.divide()` method:\n\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        cls.calculator = Calculator()\n\n    def test_divide_nonzero(self):\n        self.assertEqual(self.calculator.divide(10, 2), 5.0)\n        self.assertAlmostEqual(self.calculator.divide(9, 3), 3.0)\n\n    def test_divide_by_zero_should_raise_error(self):\n        with self.assertRaisesRegex(Exception, \"Cannot divide by zero\"):\n            self.calculator.divide(10, 0)\n        \n        # You can add more assertions here to confirm the error message\n        exception_message = str(sys.exc_info()[1]) \n        expected_exception_msg = 'Cannot divide by zero'\n        self.assertIn(expected_exception_msg, exception_message)\n\n    def test_divide_negative(self):\n        with self.assertRaisesRegex(Exception, \"Cannot divide by zero\"):\n            self.calculator.divide(-10, 0)\n        \n        # You can add more assertions here to confirm the error message\n        exception_message = str(sys.exc_info()[1]) \n        expected_exception_msg = 'Cannot divide by zero'\n        self.assertIn(expected_exception_msg, exception_message)\n\n    def test_divide_zero(self):\n        with self.assertRaisesRegex(Exception, \"Cannot divide by zero\"):\n            self.calculator.divide(0, 10)\n        \n        # You can add more assertions here to confirm the error message\n        exception_message = str(sys.exc_info()[1]) \n        expected_exception_msg = 'Cannot divide by zero'\n        self.assertIn(expected_exception_msg, exception_message)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nNote: The original code raises a string instead of an actual Exception. In real-world applications and best practices in Python, you would raise specific exceptions like `ZeroDivisionError`. However, since the provided class uses this custom behavior (raising \"Cannot divide by zero\" as strings), I've kept consistent with that pattern.\n\nIf you'd prefer to use standard exception handling for raising errors instead of returning error messages directly from methods:\n\n```python\ndef divide(self,a,b):\n    if(b==0):\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    return a/b\n```\n\nThen the unittest test cases would be adjusted accordingly. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-phi4-mini",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:10:05.535898900Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-gemma3",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T08:59:47.511406500Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-starling-lm",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:43:04.287979900Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-llama2-uncensored",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:43:27.269329600Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here are the JUnit5 tests for the `subtract` method in the `Calculator` class:\\n\\n1. `SubtractTwoNumbers.java`:\\n```\\npackage com.example;\\n\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\npublic class SubtractTwoNumbers {\\n \\n @Test\\n public void testSubtractTwoNumbers() {\\n Calculator calculator = new Calculator();\\n assertEquals(0, calculator.subtract(4, 3)); // a - b = a + (-b) = (a-b)+(-b)= a-b;\\n }\\n}\\n```\\nThis test checks that the `subtract` method subtracts two numbers and returns the result as an integer. In this case, the expected value is zero because 4 minus 3 equals 1 which is added to (-3) to get -2 (the sign of 4 changes). The final result is -2 since 4 is added to 0.\\n\\n2. `SubtractTwoIntegers.java`:\\n```\\npackage com.example;\\n\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\npublic class SubtractTwoIntegers {\\n \\n @Test\\n public void testSubtractTwoNumbers() {\\n Calculator calculator = new Calculator();\\n assertEquals(0, calculator.subtract(-4, -3)); // a + (-b) = (a+b)-2*b=a-2*b;\\n }\\n}\\n```\\nThis test checks that the `subtract` method subtracts two integers and returns the result as an integer. In this case, the expected value is zero because -4 minus 3 equals -1 which is added to (-3) to get -4 (the sign of 4 changes). The final result is -4 since -4 is added to 0.\\n\\nThese tests cover both cases where a positive and negative integer are passed to the `subtract` method. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Test Case #1:\\npublic class CalculatorTest {\\n  @Test\\n  void testAdd() {\\n    assertEquals(5.0f, new Calculator().add(2.0f, 3.0f), \\\"Addition should return 5\\\");\\n  }\\n}\\n\\nTest Case #2:\\npublic class CalculatorTest {\\n  @Test\\n  void testSubtract() {\\n    assertEquals(-1.0f, new Calculator().subtract(4.0f, -3.0f), \\\"Subtraction should return -1\\\");\\n  }\\n}\\n\\nTest Case #3:\\npublic class CalculatorTest {\\n  @Test\\n  void testMultiply() {\\n    assertEquals(-6.0f, new Calculator().multiply(2.0f, -3.0f), \\\"Multiplication should return -6\\\");\\n  }\\n} \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here are some possible tests you could create for the `multiply` method in the `Calculator` class:\\n1. Test cases for all possible input combinations, including negative numbers and zero values. Example:\\n```java\\n@Test\\npublic void testMultiplication() {\\n double a = 2;\\n double b = -3;\\n assertThat(Calculator.multiply(a,b),is(-6));\\n a = 0;\\n b = 1;\\n assertThat(Calculator.multiply(a,b),is(0));\\n}\\n```\\n2. Test cases for edge cases and corner cases, such as testing the method with very large or very small inputs. Example:\\n```java\\n@Test\\npublic void testMultiplicationOutsideRange() {\\n double a = -1;\\n assertThatIllegalArgumentException().isThrownBy(() -> Calculator.multiply(a, 2));\\n a = 100;\\n b = 0;\\n assertThatIllegalArgumentException().isThrownBy(() -> Calculator.multiply(a,b));\\n}\\n```\\n3. Test cases to ensure that the method is working as expected in different conditions, such as testing the output with positive and negative numbers. Example:\\n```java\\n@Test\\npublic void testMultiplicationPositiveAndNegative() {\\n double a = 5;\\n double b = -10;\\n assertThat(Calculator.multiply(a,b),is(-50));\\n a = -4;\\n b = 2;\\n assertThat(Calculator.multiply(a,b),is(8));\\n}\\n``` \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n Here are some JUnit 5 test cases for the `Calculator` class:\\n\\n```java\\nimport org.junit.*;\\nimport org.junit.platform.commons.annotation.Immutable;\\nimport static org.assertj.core.api.Assertions.*;\\n\\n@Test\\npublic void testSubtractNull() {\\n Calculator calculator = new Calculator();\\n \\n double expectedResult = null;\\n double result = calculator.subtract(null, 1);\\n assertThat(result).isEqualTo(expectedResult);\\n }\\n \\n @Test\\n public void testSubtractNegative() {\\n Calculator calculator = new Calculator();\\n \\n double expectedResult = -2;\\n double result = calculator.subtract(-1, 2);\\n assertThat(result).isEqualTo(expectedResult);\\n }\\n \\n @Test\\n public void testSubtractZero() {\\n Calculator calculator = new Calculator();\\n \\n double expectedResult = 0;\\n double result = calculator.subtract(1, 0);\\n assertThat(result).isEqualTo(expectedResult);\\n }\\n``` \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='neural-chat', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-neural-chat",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:42:52.227688500Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  from unittest import TestCase\\n\\nclass CalculatorTests(TestCase):\\n    def test_add(self):\\n        calculator = Calculator()\\n        self.assertEqual(calculator.add(1, 2), 3)\\n        self.assertEqual(calculator.add(-5, 0), -5)\\n        self.assertEqual(calculator.add(9, 8), 17) \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  import unittest\\nfrom calculator_class import Calculator\\n\\nclass TestCalculatorClass(unittest.TestCase):\\n    def setUp(self):\\n        self.calculator = Calculator()\\n\\n    def test_subtract(self):\\n        # Test case 1: Positive numbers\\n        result = self.calculator.subtract(2, 1)\\n        expected_result = 1\\n        self.assertEqual(result, expected_result)\\n\\n        # Test case 2: Negative numbers\\n        result = self.calculator.subtract(-2, -1)\\n        expected_result = -3\\n        self.assertEqual(result, expected_result)\\n\\nif __name__ == '__main__':\\n    unittest.main() \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  from unittest import TestCase\\n\\nclass CalculatorTests(TestCase):\\n    def setUp(self) -> None:\\n        self.calculator = Calculator()  # Create an instance of the class to be tested\\n\\n    def test_multiply_positive_numbers(self):\\n        a = 5\\n        b = 6\\n        expected_result = 30\\n        result = self.calculator.multiply(a, b)\\n        self.assertEqual(expected_result, result)\\n\\n    def test_multiply_negative_numbers(self):\\n        a = -5\\n        b = -6\\n        expected_result = 30\\n        result = self.calculator.multiply(a, b)\\n        self.assertEqual(expected_result, result)\\n\\n    def test_multiply_zero_with_positive_number(self):\\n        a = 0\\n        b = 6\\n        expected_result = 0\\n        result = self.calculator.multiply(a, b)\\n        self.assertEqual(expected_result, result)\\n\\n    def test_multiply_zero_with_negative_number(self):\\n        a = 0\\n        b = -6\\n        expected_result = 0\\n        result = self.calculator.multiply(a, b)\\n        self.assertEqual(expected_result, result)\\n\\n    def test_multiply_one_with_positive_number(self):\\n        a = 1\\n        b = 6\\n        expected_result = 6\\n        result = self.calculator.multiply(a, b)\\n        self.assertEqual(expected_result, result)\\n\\n    def test_multiply_one_with_negative_number(self):\\n        a = 1\\n        b = -6\\n        expected_result = -6\\n        result = self.calculator.multiply(a, b)\\n        self.assertEqual(expected_result, result)\\n\\n    def test_multiply_with_different_types(self):\\n        a = 5\\n        b = '6'\\n        expected_result = ValueError\\n        self.assertRaises(ValueError, lambda: self.calculator.multiply(a, b))\\n\\n    def tearDown(self) -> None:\\n        pass \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  From unittest import TestCase, main\\n\\nclass TestCalculator(TestCase):\\n    def setUp(self):\\n        self.calc = Calculator()\\n\\n    def test_divide_with_valid_input(self):\\n        result = self.calc.divide(20, 3)\\n        self.assertEqual(result, 6.666666666666667)\\n\\n    def test_divide_by_zero(self):\\n        with self.assertRaises(Exception):\\n            self.calc.divide(10, 0)\\n\\nif __name__ == '__main__':\\n    main() \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-granite3.3",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:58:08.403259500Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Report not found coverage.json"
      },
      "llmModel": "cache-Ollama-gemma3:1b",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T08:59:34.994025300Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-neural-chat",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:42:51.873845100Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "Tools.CodeParsers.ParsingException",
          "message": "no Java coe found"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  To create JUnit 5 tests for the given Calculator class and its subtract method, we will write test cases to check different scenarios. Here is an example showing how to test with positive values, negative values, and zero value. We'll also add a custom assertion to ensure the expected result is equal to the actual result of the subtraction.\\n\\n1. Create a new Java file called \\\"CalculatorTest\\\" inside a JUnit 5 compatible project (either a new empty Maven project or an existing one).\\n\\n2. Import the necessary classes from JUnit and the Calculator class:\\n   import org.junit.jupiter.api.Assertions;\\n   import org.junit.jupiter.api.Test;\\n   import static com.example.myapp.Calculator.*;\\n\\n3. Define a test method to check the subtraction of positive values using assertAll() and Assertions:\\n    @Test\\n    public void testSubtractPositiveValues() {\\n        int a = 10;\\n        int b = 5;\\n        int expectedResult = 5;\\n\\n        Assertions.assertAll(\\n            () -> Assertions.assertEquals(expectedResult, subtract(a, b)),\\n            () -> Assertions.assertTrue(subtract(a, b) == expectedResult),\\n            () -> Assertions.assertNotSame(a - b, 6) // check if the result is not 6\\n        );\\n    }\\n\\n4. Define a test method to check the subtraction of negative values using assertAll() and Assertions:\\n   @Test\\n   public void testSubtractNegativeValues() {\\n       int a = -10;\\n       int b = -5;\\n       int expectedResult = 5;\\n\\n       Assertions.assertAll(\\n           () -> Assertions.assertEquals(expectedResult, subtract(a, b)),\\n           () -> Assertions.assertTrue(subtract(a, b) == expectedResult),\\n           () -> Assertions.assertNotSame(a - b, 6) // check if the result is not 6\\n       );\\n   }\\n\\n5. Define a test method to check the subtraction of zero value using assertAll() and Assertions:\\n   @Test\\n   public void testSubtractZeroValue() {\\n       int a = 10;\\n       int b = 0;\\n       int expectedResult = 10;\\n\\n       Assertions.assertAll(\\n           () -> Assertions.assertEquals(expectedResult, subtract(a, b)),\\n           () -> Assertions.assertTrue(subtract(a, b) == expectedResult),\\n           () -> Assertions.assertNotSame(a - b, 6) // check if the result is not 6\\n       );\\n   }\\n\\nBy following these steps, you can create JUnit 5 tests for the subtract method in the Calculator class. Add more test cases to cover other scenarios and ensure proper functioning of your code. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  package com.test;\\n\\nimport org.junit.jupiter.api.Assertions;\\nimport org.junit.jupiter.api.Test;\\n\\npublic class CalculatorTests {\\n    @Test\\n    public void testMultiplyPositiveNumbers() {\\n        int expectedResult = 400;\\n        int a = 20;\\n        int b = 20;\\n        int actualResult = com.test.Calculator.multiply(a, b);\\n\\n        Assertions.assertEquals(expectedResult, actualResult);\\n    }\\n\\n    @Test\\n    public void testMultiplyNegativeNumbers() {\\n        int expectedResult = -40;\\n        int a = -5;\\n        int b = 8;\\n        int actualResult = com.test.Calculator.multiply(a, b);\\n\\n        Assertions.assertEquals(expectedResult, actualResult);\\n    }\\n\\n    @Test\\n    public void testMultiplyingZero() {\\n        int expectedResult = 0;\\n        int a = 0;\\n        int b = 5;\\n        int actualResult = com.test.Calculator.multiply(a, b);\\n\\n        Assertions.assertEquals(expectedResult, actualResult);\\n    }\\n} \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  package testing.calculator;\\n\\nimport static org.junit.jupiter.api.Assertions.*;\\nimport org.junit.jupiter.api.Test;\\n\\nclass CalculatorTest {\\n    @Test\\n    void testDivideWithValidInputs() {\\n        int result = Calculator.divide(10, 2);\\n        assertEquals(5, result);\\n    }\\n    \\n    @Test\\n    void testDivideByZero() {\\n        assertThrows(ArithmeticException.class, () -> Calculator.divide(10, 0));\\n    }\\n}\\n\\nThis code creates JUnit5 tests for the given function called \\\"divide\\\" from the class \\\"Calculator\\\". The first test checks if the function returns the correct result when dividing two valid integers, while the second test ensures that an exception is thrown when trying to divide by zero. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  package test.calculator;\\n\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTest {\\n    @Test\\n    public void divideByZeroExceptionTest() {\\n        // Test for ArithmeticException when dividing by zero\\n        AssertionError exception = assertThrows(ArithmeticException.class, () -> Calculator.divide(1f, 0));\\n        assertEquals(\\\"Divide by zero\\\", exception.getMessage());\\n    }\\n}\\n\\npackage test.calculator;\\n\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTest {\\n    @Test\\n    public void divideSuccessfulTest() {\\n        // Test successful division\\n        float result = Calculator.divide(5f, 2f);\\n        assertEquals(2.5f, result, \\\"2.5 should be the result of dividing 5 by 2\\\");\\n    }\\n} \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  package com.example.testcases;\\n\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nimport org.junit.jupiter.api.Test;\\n\\nclass CalculatorSubtractTests {\\n    @Test\\n    void test_subtract_positiveNumbers() {\\n        // Given\\n        float a = 10f, b = 5f;\\n\\n        // When\\n        float result = Calculator.subtract(a, b);\\n\\n        // Then\\n        assertEquals(5f, result, \\\"Subtraction of positive numbers should be correct\\\");\\n    }\\n\\n    @Test\\n    void test_subtract_negativeNumbers() {\\n        // Given\\n        float a = -10f, b = -5f;\\n\\n        // When\\n        float result = Calculator.subtract(a, b);\\n\\n        // Then\\n        assertEquals(-15f, result, \\\"Subtraction of negative numbers should be correct\\\");\\n    }\\n\\n    @Test\\n    void test_subtract_mixedNumbers() {\\n        // Given\\n        float a = 10f, b = -5f;\\n\\n        // When\\n        float result = Calculator.subtract(a, b);\\n\\n        // Then\\n        assertEquals(5f, result, \\\"Subtraction of mixed numbers should be correct\\\");\\n    }\\n} \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n  import org.junit.jupiter.api.Assertions;\\nimport org.junit.jupiter.api.Test;\\n\\nclass CalculatorTests {\\n    @Test\\n    public void testAdd() {\\n        double result = Calculator.add(10, 20);\\n        Assertions.assertEquals(30, result, \\\"The sum of 10 and 20 should be 30\\\");\\n    }\\n}\\n\\nHere's a basic JUnit5 test class with tests for the add function in Calculator class. Make sure to import the needed classes and place them into your Java project along with the Calculator class. You can extend the functionality of the unit tests according to your requirements. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__]) using OllamaProcessors(model='codellama', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-codellama",
      "project": "PythonCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:43:14.952743600Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   To write unit tests for the `Calculator` class using the `unittest` module in Python, you can follow these steps:\\n\\n1. Import the `unittest` module at the top of your test file:\\n```\\nimport unittest\\n```\\n2. Create a new test case class that inherits from `unittest.TestCase`:\\n```\\nclass CalculatorTest(unittest.TestCase):\\n    pass\\n```\\n3. Define test methods in the test case class using the `test_` prefix:\\n```\\ndef test_add(self):\\n    calculator = Calculator()\\n    result = calculator.add(2, 3)\\n    self.assertEqual(result, 5)\\n\\ndef test_subtract(self):\\n    calculator = Calculator()\\n    result = calculator.subtract(2, 3)\\n    self.assertEqual(result, -1)\\n```\\n4. Run the test cases using the `unittest.main()` function:\\n```\\nif __name__ == '__main__':\\n    unittest.main()\\n```\\n5. The output should be similar to this:\\n```\\n$ python calculator_test.py \\ntest_add (__main__.CalculatorTest) ... ok\\ntest_subtract (__main__.CalculatorTest) ... ok\\n\\n----------------------------------------------------------------------\\nRan 2 tests in 0.001s\\n\\nOK\\n```\\nNote that the output may vary depending on your system and the specific test cases you have written. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Tests for `Calculator.subtract()`:\\n```\\nimport unittest\\nfrom calculator import Calculator\\n\\nclass TestCalculator(unittest.TestCase):\\n    def test_subtract(self):\\n        calc = Calculator()\\n        self.assertEqual(calc.subtract(10, 5), 5)\\n```\\nThis test case tests the subtract method of the calculator class by asserting that when we subtract 5 from 10, the result is equal to 5.\\n\\nAlternatively, you can also use a parameterized test to test multiple inputs and outputs using a single test function.\\n```\\nimport unittest\\nfrom calculator import Calculator\\n\\nclass TestCalculator(unittest.TestCase):\\n    @parameterized.expand([(10, 5, 5), (20, 10, 10), (30, 20, 10)])\\n    def test_subtract(self, a, b, expected_result):\\n        calc = Calculator()\\n        self.assertEqual(calc.subtract(a, b), expected_result)\\n```\\nThis test case uses the `parameterized` library to create multiple test cases using a single function. The `@parameterized.expand` decorator is used to pass in each tuple of inputs and their corresponding expected outputs as arguments to the test function. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   To write unit tests for the `multiply` method of the `Calculator` class, you can use the following code:\\n```\\nimport unittest\\n\\nclass TestCalculator(unittest.TestCase):\\n    def test_multiply(self):\\n        calculator = Calculator()\\n        result = calculator.multiply(2, 3)\\n        self.assertEqual(result, 6)\\n\\nif __name__ == '__main__':\\n    unittest.main()\\n```\\nThis code defines a new test class `TestCalculator` that inherits from the `unittest.TestCase` class. The test class contains a single test method called `test_multiply`, which instantiates an instance of the `Calculator` class and calls its `multiply` method with arguments 2 and 3. It then checks that the result is equal to 6 using the `self.assertEqual` method provided by the `unittest.TestCase` class.\\n\\nThe `if __name__ == '__main__':` line at the end of the code is used to run the unit tests when the file is executed as a script. You can run this file in your terminal or command prompt by typing `python test_calculator.py`. If the unit tests pass, you should see output similar to the following:\\n```\\n$ python test_calculator.py\\n...\\n----------------------------------------------------------------------\\nRan 1 test in 0.001s\\n\\nOK\\n```\\nIf the unit tests fail, you will see an error message indicating which test failed and why. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Tests for the divide method of the Calculator class:\\n```\\nimport unittest\\nfrom calculator import Calculator\\n\\nclass TestCalculator(unittest.TestCase):\\n    def test_divide(self):\\n        calc = Calculator()\\n        self.assertEqual(calc.divide(10, 2), 5)\\n        self.assertEqual(calc.divide(10, 3), 3.33)\\n        self.assertEqual(calc.divide(10, 4), 2.5)\\n        with self.assertRaises(ZeroDivisionError):\\n            calc.divide(10, 0)\\n\\nif __name__ == '__main__':\\n    unittest.main()\\n```\\nThis test case verifies that the divide method of the Calculator class works correctly for different input values. It first creates an instance of the Calculator class and calls the divide method with different arguments to test the correctness of the result. The test case also uses the assertRaises method to verify that a ZeroDivisionError is raised when attempting to divide by zero. \n]]\n frotm project [[Project(name=PythonCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\PythonCalculator, codeParser=Tools.CodeParsers.PythonParser@571a663c, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.PythonRunner@3a788fe0, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Pytest.PytestReportExtractor@430df350, testingFramework=unittest, codeFileExtension=py, ignoredFiles=[tests\\__pycache__])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[]) using OllamaProcessors(model='codellama', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-codellama",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:43:14.639174800Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some examples of JUnit 5 tests that you can use to test the `add` method of your `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\n\\nclass CalculatorTests {\\n    @Test\\n    void add_shouldReturnTheSumOfTwoIntegers() {\\n        assertEquals(4, new Calculator().add(2, 2));\\n    }\\n\\n    @Test\\n    void add_shouldReturnZeroWhenCalledWithNoParameters() {\\n        assertEquals(0, new Calculator().add());\\n    }\\n\\n    @Test\\n    void add_shouldThrowAnExceptionWhenCalledWithNullParameters() {\\n        assertThrows(IllegalArgumentException.class, () -> new Calculator().add(null, 2));\\n        assertThrows(IllegalArgumentException.class, () -> new Calculator().add(2, null));\\n    }\\n}\\n```\\nIn these tests, we use the `assertEquals` method to verify that the result of calling the `add` method with different parameters is correct. We also use the `assertThrows` method to verify that the method throws an exception when called with invalid arguments. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some examples of JUnit5 tests for the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTests {\\n\\n    @Test\\n    void testSubtract() {\\n        int a = 5;\\n        int b = 3;\\n        int result = Calculator.subtract(a, b);\\n        assertEquals(2, result);\\n    }\\n\\n    @Test\\n    void testSubtractNegative() {\\n        int a = -5;\\n        int b = 3;\\n        int result = Calculator.subtract(a, b);\\n        assertEquals(-8, result);\\n    }\\n\\n    @Test\\n    void testSubtractZero() {\\n        int a = 0;\\n        int b = 0;\\n        int result = Calculator.subtract(a, b);\\n        assertEquals(0, result);\\n    }\\n}\\n```\\nThese tests cover three scenarios:\\n\\n* `testSubtract`: The subtract method is called with positive integers (5 and 3) as arguments, and the expected result (2) is compared to the actual result.\\n* `testSubtractNegative`: The subtract method is called with negative integers (-5 and 3) as arguments, and the expected result (-8) is compared to the actual result.\\n* `testSubtractZero`: The subtract method is called with zero as both arguments, and the expected result (0) is compared to the actual result. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some examples of JUnit 5 tests for the `multiply` method in the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTests {\\n    @Test\\n    void multiplyTwoPositiveNumbers() {\\n        int result = Calculator.multiply(2, 3);\\n        assertEquals(6, result);\\n    }\\n\\n    @Test\\n    void multiplyNegativeAndPositiveNumber() {\\n        int result = Calculator.multiply(-2, 3);\\n        assertEquals(-6, result);\\n    }\\n\\n    @Test\\n    void multiplyTwoNegativeNumbers() {\\n        int result = Calculator.multiply(-2, -3);\\n        assertEquals(6, result);\\n    }\\n\\n    @Test\\n    void multiplyZeroWithAnyNumber() {\\n        int result = Calculator.multiply(0, 3);\\n        assertEquals(0, result);\\n\\n        result = Calculator.multiply(0, -3);\\n        assertEquals(0, result);\\n    }\\n}\\n```\\nThese tests cover the following cases:\\n\\n* Multiplying two positive numbers (2 and 3)\\n* Multiplying a negative number with a positive number (-2 and 3)\\n* Multiplying two negative numbers (-2 and -3)\\n* Multiplying zero with any number (0 and 3, 0 and -3)\\n\\nNote that the `assertEquals` method is used to verify that the result of the multiplication operation is equal to the expected value. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Sure, here are some JUnit5 tests for the `divide` method of the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Assertions;\\nimport org.junit.jupiter.api.Test;\\n\\nclass CalculatorTest {\\n\\n    @Test\\n    void testDivide() {\\n        Assertions.assertEquals(2, Calculator.divide(10, 5));\\n    }\\n\\n    @Test\\n    void testDivideByZero() {\\n        Assertions.assertThrows(ArithmeticException.class, () -> Calculator.divide(10, 0));\\n    }\\n}\\n```\\nThe first test, `testDivide`, verifies that the `divide` method returns the correct result when given valid arguments (in this case, 10 and 5). The second test, `testDivideByZero`, verifies that an `ArithmeticException` is thrown when attempting to divide by zero.\\n\\nNote that these tests are just examples, and you may need to modify them to fit the specific needs of your own code. Additionally, you can use other JUnit5 annotations such as `@BeforeEach`, `@AfterEach`, `@ParameterizedTest`, etc. to create more robust tests. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some examples of JUnit5 tests that you could write for the `multiply` method in your `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTest {\\n    \\n    @Test\\n    void multiply_twoPositiveNumbers_returnsProduct() {\\n        float a = 2f;\\n        float b = 3f;\\n        float result = Calculator.multiply(a, b);\\n        assertEquals(6f, result);\\n    }\\n    \\n    @Test\\n    void multiply_twoNegativeNumbers_returnsProduct() {\\n        float a = -2f;\\n        float b = -3f;\\n        float result = Calculator.multiply(a, b);\\n        assertEquals(-6f, result);\\n    }\\n    \\n    @Test\\n    void multiply_twoZeroNumbers_returnsProduct() {\\n        float a = 0f;\\n        float b = 0f;\\n        float result = Calculator.multiply(a, b);\\n        assertEquals(0f, result);\\n    }\\n    \\n    @Test\\n    void multiply_onePositiveOneNegativeNumbers_returnsProduct() {\\n        float a = 2f;\\n        float b = -3f;\\n        float result = Calculator.multiply(a, b);\\n        assertEquals(-6f, result);\\n    }\\n    \\n    @Test\\n    void multiply_oneNegativeOnePositiveNumbers_returnsProduct() {\\n        float a = -2f;\\n        float b = 3f;\\n        float result = Calculator.multiply(a, b);\\n        assertEquals(-6f, result);\\n    }\\n    \\n}\\n```\\nThese tests cover different scenarios for multiplying two numbers, including positive and negative numbers, zero, and one of the numbers being a mixture of positive and negative values.\\n\\nYou can run these tests using the JUnit5 test runner by creating a new instance of `CalculatorTest` and calling the `multiply_twoPositiveNumbers_returnsProduct()` method on it. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some JUnit5 tests for the `divide` method of the `Calculator` class:\\n```\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTest {\\n\\n    @Test\\n    void testDivide() {\\n        Calculator calculator = new Calculator();\\n        float result = calculator.divide(10, 2);\\n        assertEquals(5f, result, 0.01);\\n    }\\n\\n    @Test\\n    void testDivideByZero() {\\n        Calculator calculator = new Calculator();\\n        try {\\n            calculator.divide(10, 0);\\n            fail(\\\"Expected ArithmeticException\\\");\\n        } catch (ArithmeticException e) {\\n            assertEquals(\\\"Divide by zero\\\", e.getMessage());\\n        }\\n    }\\n}\\n```\\nThe first test, `testDivide`, tests that the `divide` method returns the correct result when given valid input. The second test, `testDivideByZero`, tests that an `ArithmeticException` is thrown when trying to divide by zero. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here is an example of how you could write JUnit 5 tests for the `add` method in the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTests {\\n    @Test\\n    void add_twoPositiveNumbers_returnsSum() {\\n        float a = 2f;\\n        float b = 3f;\\n        float result = Calculator.add(a, b);\\n        assertEquals(5f, result);\\n    }\\n\\n    @Test\\n    void add_twoNegativeNumbers_returnsSum() {\\n        float a = -2f;\\n        float b = -3f;\\n        float result = Calculator.add(a, b);\\n        assertEquals(-5f, result);\\n    }\\n\\n    @Test\\n    void add_twoPositiveAndNegativeNumbers_returnsSum() {\\n        float a = 2f;\\n        float b = -3f;\\n        float result = Calculator.add(a, b);\\n        assertEquals(-1f, result);\\n    }\\n}\\n```\\nThese tests check that the `add` method correctly adds two floating-point numbers and returns the sum as a `float`. The first test checks that adding two positive numbers results in the correct sum. The second test checks that adding two negative numbers results in the correct sum. The third test checks that adding a positive and a negative number results in the correct sum.\\n\\nYou can run these tests using JUnit 5 by creating a test suite and running it with the `java` command:\\n```\\n$ java -jar junit-platform-console-standalone.jar --select-class=CalculatorTests\\n```\\nThis will execute all of the tests in the `CalculatorTests` class and report any failures or errors that occur during the test run. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here is an example of how you could write JUnit 5 tests for the `subtract` method in the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTests {\\n    @Test\\n    void testSubtract() {\\n        // Test with two positive numbers\\n        assertEquals(10, Calculator.subtract(20, 10));\\n        // Test with two negative numbers\\n        assertEquals(-20, Calculator.subtract(-10, -30));\\n        // Test with a positive and negative number\\n        assertEquals(-15, Calculator.subtract(10, -5));\\n    }\\n}\\n```\\nThis test class has one test method called `testSubtract` that tests the `subtract` method in the `Calculator` class. The method uses the JUnit 5 `assertEquals` method to make assertions about the results of the `subtract` method. In this case, it tests that the result is equal to the expected value.\\n\\nYou can run these tests using a test runner like Maven or Gradle, or by right-clicking on the class file in your IDE and selecting \\\"Run Tests\\\". The output will show you whether the tests passed or failed, and any errors or failures that occurred during the test execution. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some examples of JUnit5 tests for the `multiply` method in the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Assertions;\\nimport org.junit.jupiter.params.ParameterizedTest;\\nimport org.junit.jupiter.params.provider.CsvSource;\\n\\npublic class CalculatorTests {\\n\\n    @ParameterizedTest\\n    @CsvSource({\\\"1, 2, 2\\\", \\\"3, 4, 12\\\", \\\"-5, -6, -30\\\"})\\n    void testMultiply(double a, double b, double expected) {\\n        Assertions.assertEquals(expected, Calculator.multiply(a, b));\\n    }\\n}\\n```\\nThis test uses the `@ParameterizedTest` annotation to indicate that it is a parameterized test, and the `@CsvSource` annotation to specify the input parameters for the test in a CSV file. The `testMultiply` method takes three double arguments: `a`, `b`, and `expected`. The test case is executed once for each row in the CSV file, with the values of `a`, `b`, and `expected` taken from the corresponding columns in the file.\\n\\nHere are some examples of JUnit5 tests for the `multiply` method that use a custom annotation:\\n```\\nimport org.junit.jupiter.api.Assertions;\\nimport org.junit.jupiter.params.ParameterizedTest;\\nimport org.junit.jupiter.params.provider.CsvSource;\\n\\npublic class CalculatorTests {\\n\\n    @ParameterizedTest\\n    @MultiplicationTest(value = 1, expected = 2)\\n    void testMultiplyOneByTwo(double a, double b, double expected) {\\n        Assertions.assertEquals(expected, Calculator.multiply(a, b));\\n    }\\n\\n    @ParameterizedTest\\n    @MultiplicationTest(value = 3, expected = 12)\\n    void testMultiplyThreeByFour(double a, double b, double expected) {\\n        Assertions.assertEquals(expected, Calculator.multiply(a, b));\\n    }\\n\\n    @ParameterizedTest\\n    @MultiplicationTest(value = -5, expected = -30)\\n    void testMultiplyNegativeFiveByNegativeSix(double a, double b, double expected) {\\n        Assertions.assertEquals(expected, Calculator.multiply(a, b));\\n    }\\n}\\n```\\nThis test uses the `@ParameterizedTest` annotation to indicate that it is a parameterized test, and the `@MultiplicationTest` annotation to specify the input parameters for the test in a custom CSV file. The `testMultiplyOneByTwo`, `testMultiplyThreeByFour`, and `testMultiplyNegativeFiveByNegativeSix` methods take three double arguments: `a`, `b`, and `expected`. The `@MultiplicationTest` annotation is used to specify the value of `a`, `b`, and `expected` for each test case, in the format of a CSV file.\\n\\nNote that these examples are just a few possibilities for how you could use JUnit5 with your calculator class. There are many other ways to write tests for a calculator using JUnit5, depending on the specific requirements of your project. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here is an example of JUnit5 tests for the `divide` method in the `Calculator` class:\\n```\\nimport static org.junit.jupiter.api.Assertions.*;\\nimport org.junit.jupiter.api.Test;\\n\\nclass CalculatorTest {\\n\\n    @Test\\n    void testDivide() {\\n        // Given\\n        double a = 10.0;\\n        double b = 2.0;\\n\\n        // When\\n        double result = Calculator.divide(a, b);\\n\\n        // Then\\n        assertEquals(5.0, result, 0.000001);\\n    }\\n\\n    @Test\\n    void testDivideByZero() {\\n        // Given\\n        double a = 10.0;\\n        double b = 0.0;\\n\\n        // When\\n        try {\\n            Calculator.divide(a, b);\\n            fail(\\\"Expected ArithmeticException to be thrown\\\");\\n        } catch (ArithmeticException e) {\\n            assertEquals(\\\"Divide by zero\\\", e.getMessage());\\n        }\\n    }\\n}\\n```\\nThe first test `testDivide` checks the result of dividing two doubles and ensures that it is equal to 5.0 with a tolerance of 0.000001. The second test `testDivideByZero` checks that an ArithmeticException is thrown when attempting to divide by zero. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some examples of JUnit 5 tests for the `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\nclass CalculatorTest {\\n    \\n    @Test\\n    void testAdd() {\\n        // Given\\n        double a = 2.0;\\n        double b = 3.0;\\n        \\n        // When\\n        double result = Calculator.add(a, b);\\n        \\n        // Then\\n        assertEquals(5.0, result);\\n    }\\n    \\n    @Test\\n    void testAdd_withNegativeNumbers() {\\n        // Given\\n        double a = -2.0;\\n        double b = -3.0;\\n        \\n        // When\\n        double result = Calculator.add(a, b);\\n        \\n        // Then\\n        assertEquals(-5.0, result);\\n    }\\n    \\n    @Test\\n    void testAdd_withZero() {\\n        // Given\\n        double a = 2.0;\\n        double b = 0.0;\\n        \\n        // When\\n        double result = Calculator.add(a, b);\\n        \\n        // Then\\n        assertEquals(2.0, result);\\n    }\\n}\\n```\\nNote that these tests are just examples and may not cover all the possible cases for the `add` method. It's up to you to decide what tests make sense for your specific use case. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n   Here are some examples of JUnit5 tests that you can use to test the `subtract` method in your `Calculator` class:\\n```\\nimport org.junit.jupiter.api.Test;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\npublic class CalculatorTests {\\n    @Test\\n    public void subtract_withValidInputs_returnsCorrectResult() {\\n        // Given\\n        double a = 10.0;\\n        double b = 5.0;\\n        double expectedResult = 5.0;\\n\\n        // When\\n        double actualResult = Calculator.subtract(a, b);\\n\\n        // Then\\n        assertEquals(expectedResult, actualResult);\\n    }\\n\\n    @Test\\n    public void subtract_withInvalidInputs_throwsException() {\\n        // Given\\n        double a = 10.0;\\n        double b = -5.0;\\n\\n        // When & Then\\n        assertThrows(IllegalArgumentException.class, () -> Calculator.subtract(a, b));\\n    }\\n}\\n```\\nIn the first test, we are testing that the `subtract` method returns the correct result when given valid inputs. We create a mock input of 10.0 for `a` and 5.0 for `b`, and then use the `assertEquals` method to check that the method returns the expected result of 5.0.\\n\\nIn the second test, we are testing that the `subtract` method throws an exception when given invalid inputs. We create a mock input of 10.0 for `a` and -5.0 for `b`, and then use the `assertThrows` method to check that an `IllegalArgumentException` is thrown.\\n\\nYou can add more tests as per your requirement, just make sure you are testing all the valid and invalid input combinations. \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "no code generated for tests on project Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[]) using OllamaProcessors(model='moondream', ollamaApi=OllamaApi(urlBase='http://localhost:18502/'))-cached"
      },
      "llmModel": "cache-Ollama-moondream",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:42:37.799466600Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "warnings": [
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1: Passes (0.01) \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1:\\nInputs: calculator.calculator.Calculator::subtract(3,2)\\nExpectations: 2\\nActual Output: 0 \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1:\\nInputs: 2 and 3\\nExpected Output: 6\\nActual output: 6 \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\n [0.12, 0.13, 0.24, 0.21] \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1: Float Values\\nExpectation: The result of the function should be an expected floating point number.\\nActual result: 0.0 \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\n [0.12, 0.13, 0.24, 0.2] \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1: Passes (0.01, 0.18, 0.1, 0.3) \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1:\\nInputs: a = 3.0, b = 2.0\\nExpected Output: 1.0 \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1:\\nInputs: 2.0, 3.0\\nExpected Output: 6.0\\nActual output: 6.0 \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\n [0.12, 0.13, 0.23, 0.2] \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1: Passes (0.01, 0.18, 0.1, 0.3) \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        },
        {
          "type": "LLM.CodeRetrivalExcpetion",
          "message": "Couldn't extract any code file from llm result: \n[[\n \\nTest Case 1:\\nInputs: 2.0, 3.0\\nExpected Output: 1.0 \n]]\n frotm project [[Project(name=JavaCalculator, ProjectPath=F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator, codeParser=org.filomilo.AiTestGenerator.Tools.CodeParsers.JavaParser@39ab5ef7, projectRunner=org.filomilo.AiTestGenerotorAnalisis.Projects.Runners.MavenRunner@120aa40b, reportExtractor=org.filomilo.AiTestGenerotorAnalisis.Projects.Reports.Jacoco.JacocoReportExtractor@32ab408e, testingFramework=Junit5, codeFileExtension=java, ignoredFiles=[])]]"
        }
      ],
      "report": null
    },
    {
      "failureReason": {
        "message": "Couldn't find jacoco report in location:: F:\\projects\\AiUnitTestPlugin\\tmp\\JavaCalculator\\target\\site\\jacoco\\jacoco.xml"
      },
      "llmModel": "cache-Ollama-mistral",
      "project": "JavaCalculator",
      "strategy": "Simple_Prompt_Strategy",
      "strategyDescription": "Simple propmpt for test generation formatted from :: \n[[ Create ##framework## tests for function ##functions## ]\n]]\n",
      "time": "2025-09-21T13:21:08.908628100Z",
      "deviceSpecification": {
        "ramBytes": 17112657920,
        "system": "Windows 11",
        "processor": {
          "name": "Intel(R) Core(TM) i5-8600 CPU @ 3.10GHz",
          "physicalCores": 6,
          "logicalCores": 6
        },
        "gpu": [
          {
            "name": "NVIDIA GeForce GTX 1060 3GB",
            "VRamBytes": 3221225472
          }
        ]
      },
      "report": null
    }
  ]
}